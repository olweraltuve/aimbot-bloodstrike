EXACT PATH <C:\Users\olwer\Documents\GitHub\AI-Aimbot\admin_check.py>: """"
Admin Permission Check and Elevation for Windows
This module provides functions to check for administrator privileges
and request elevation if needed for the AI Aimbot application.
"""

import ctypes
import os
import sys
import subprocess
import platform
from termcolor import colored

def is_admin():
    """
    Check if the current process has administrator privileges.
    
    Returns:
        bool: True if running as administrator, False otherwise
    """
    try:
        # Method 1: Check using ctypes (Windows)
        if platform.system() == 'Windows':
            return ctypes.windll.shell32.IsUserAnAdmin()
        else:
            # On non-Windows systems, check for root/sudo
            return os.geteuid() == 0
    except Exception as e:
        print(f"[WARNING] Failed to check admin status: {e}")
        return False

def request_admin_elevation():
    """
    Request administrator privileges by restarting the script with UAC prompt.
    
    Returns:
        bool: True if elevation was requested, False if already admin or failed
    """
    if is_admin():
        return False  # Already running as admin
    
    print(colored("[INFO] Administrator privileges required for optimal performance", "yellow"))
    print(colored("[INFO] Requesting elevation via UAC...", "yellow"))
    
    try:
        # Get the current script path
        script = os.path.abspath(sys.argv[0])
        params = ' '.join([f'"{arg}"' for arg in sys.argv[1:]])
        
        # Request UAC elevation
        ctypes.windll.shell32.ShellExecuteW(
            None,  # hwnd
            "runas",  # operation (run as administrator)
            sys.executable,  # executable (Python interpreter)
            f'"{script}" {params}',  # parameters
            None,  # working directory
            1  # nShow (SW_SHOWNORMAL)
        )
        
        print(colored("[SUCCESS] Admin elevation requested. Please accept UAC prompt.", "green"))
        return True
        
    except Exception as e:
        print(colored(f"[ERROR] Failed to request admin elevation: {e}", "red"))
        print(colored("[INFO] You can run the application as administrator manually", "yellow"))
        return False

def check_and_request_admin():
    """
    Main function to check admin status and request elevation if needed.
    
    Returns:
        bool: True if running as admin or elevation successful, False otherwise
    """
    if is_admin():
        print(colored("[SUCCESS] Running with administrator privileges", "green"))
        return True
    
    print(colored("[WARNING] Running without administrator privileges", "yellow"))
    print(colored("[INFO] Some features may not work optimally:", "yellow"))
    print(colored("  - Low-level mouse input simulation", "yellow"))
    print(colored("  - Screen capture in fullscreen applications", "yellow"))
    print(colored("  - System-level optimizations", "yellow"))
    
    # Ask user if they want to elevate
    try:
        response = input(colored("Do you want to restart with admin privileges? (y/N): ", "cyan")).strip().lower()
        if response in ['y', 'yes']:
            if request_admin_elevation():
                sys.exit(0)  # Exit current process, elevated one will start
            else:
                print(colored("[INFO] Continuing without admin privileges...", "yellow"))
                return False
        else:
            print(colored("[INFO] Continuing without admin privileges...", "yellow"))
            return False
    except (KeyboardInterrupt, EOFError):
        print(colored("\n[INFO] Continuing without admin privileges...", "yellow"))
        return False

def get_admin_benefits():
    """
    Returns a description of benefits when running with admin privileges.
    """
    benefits = [
        "Enhanced mouse input simulation for better anti-cheat compatibility",
        "Improved screen capture in fullscreen applications",
        "Better system resource management",
        "Reduced input latency",
        "Compatibility with more game protection systems"
    ]
    return benefits

if __name__ == "__main__":
    # Test the admin check functionality
    print("Admin Permission Check Test")
    print(f"Running as admin: {is_admin()}")
    
    if not is_admin():
        print("Benefits of admin privileges:")
        for benefit in get_admin_benefits():
            print(f"  - {benefit}")
        
        if input("Test elevation? (y/N): ").lower() == 'y':
            check_and_request_admin()";

---------------------

EXACT PATH <C:\Users\olwer\Documents\GitHub\AI-Aimbot\install_python312.bat>: "@echo off
echo ===============================================
echo Python 3.12 Installation Script
echo ===============================================
echo.
echo This will install Python 3.12 alongside your existing Python 3.13
echo without overwriting or affecting your current installation.
echo.

echo Downloading Python 3.12 installer...
powershell -Command "Invoke-WebRequest -Uri 'https://www.python.org/ftp/python/3.12.0/python-3.12.0-amd64.exe' -OutFile 'python312-installer.exe'"

if exist python312-installer.exe (
    echo.
    echo Running Python 3.12 installer...
    echo IMPORTANT: During installation, make sure to:
    echo   - Check "Add python.exe to PATH"
    echo   - Click "Customize installation"
    echo   - In Advanced Options, check "Install for all users"
    echo   - Change installation path to: C:\Python312\
    echo   - DO NOT check "Associate files with Python"
    echo.
    echo The installer will now open. Please follow the instructions above.
    echo.
    pause
    start /wait python312-installer.exe
) else (
    echo Failed to download Python 3.12 installer
    echo Please download manually from:
    echo https://www.python.org/downloads/release/python-3120/
    pause
    exit /b 1
)

echo.
echo Cleaning up installer...
del python312-installer.exe

echo.
echo Verifying Python 3.12 installation...
where python3.12 >nul 2>&1
if %errorlevel% equ 0 (
    echo Python 3.12 successfully installed!
    echo.
    echo Now run setup_cuda.bat to set up the CUDA environment.
) else (
    echo Python 3.12 installation may have failed.
    echo Please check if Python 3.12 is available in your system.
)

echo.
pause";

---------------------

EXACT PATH <C:\Users\olwer\Documents\GitHub\AI-Aimbot\install_python313.bat>: "@echo off
echo ===============================================
echo Python 3.13 Installation Script
echo ===============================================
echo.
echo This will install Python 3.13 for Windows.
echo.

echo Downloading Python 3.13 installer...
powershell -Command "Invoke-WebRequest -Uri 'https://www.python.org/ftp/python/3.13.0/python-3.13.0-amd64.exe' -OutFile 'python313-installer.exe'"

if exist python313-installer.exe (
    echo.
    echo Running Python 3.13 installer...
    echo IMPORTANT: During installation, make sure to:
    echo   - Check "Add python.exe to PATH"
    echo   - Click "Customize installation"
    echo   - In Advanced Options, check "Install for all users"
    echo   - Change installation path to: C:\Python313\
    echo   - DO NOT check "Associate files with Python"
    echo.
    echo The installer will now open. Please follow the instructions above.
    echo.
    pause
    start /wait python313-installer.exe
) else (
    echo Failed to download Python 3.13 installer
    echo Please download manually from:
    echo https://www.python.org/downloads/release/python-3130/
    pause
    exit /b 1
)

echo.
echo Cleaning up installer...
del python313-installer.exe

echo.
echo Verifying Python 3.13 installation...
where python >nul 2>&1
if %errorlevel% equ 0 (
    echo Python 3.13 successfully installed!
    echo.
    echo Now run setup_cuda.bat to set up the CUDA environment.
) else (
    echo Python 3.13 installation may have failed.
    echo Please check if Python 3.13 is available in your system.
)

echo.
pause";

---------------------

EXACT PATH <C:\Users\olwer\Documents\GitHub\AI-Aimbot\install_requirements.bat>: "pip install -r requirements.txt --no-cache-dir
pause
";

---------------------

EXACT PATH <C:\Users\olwer\Documents\GitHub\AI-Aimbot\lunar.py>: "import json
import os
import sys
from pynput import keyboard
from termcolor import colored

# Import admin check module
try:
    from admin_check import check_and_request_admin
except ImportError:
    print("[WARNING] Admin check module not found. Running without admin privileges check.")
    def check_and_request_admin():
        return False

def on_release(key):
    try:
        if key == keyboard.Key.f1:
            Aimbot.update_status_aimbot()
        if key == keyboard.Key.f2:
            Aimbot.clean_up()
    except NameError:
        pass

def main():
    global lunar
    lunar = Aimbot(collect_data = "collect_data" in sys.argv)
    lunar.start()

def setup():
    path = "lib/config"
    if not os.path.exists(path):
        os.makedirs(path)

    print("[INFO] In-game X and Y axis sensitivity should be the same")
    def prompt(str):
        valid_input = False
        while not valid_input:
            try:
                number = float(input(str))
                valid_input = True
            except ValueError:
                print("[!] Invalid Input. Make sure to enter only the number (e.g. 6.9)")
        return number

    xy_sens = prompt("X-Axis and Y-Axis Sensitivity (from in-game settings): ")
    targeting_sens = prompt("Targeting Sensitivity (from in-game settings): ")

    print("[INFO] Your in-game targeting sensitivity must be the same as your scoping sensitivity")
    sensitivity_settings = {"xy_sens": xy_sens, "targeting_sens": targeting_sens, "xy_scale": 10/xy_sens, "targeting_scale": 1000/(targeting_sens * xy_sens)}

    with open('lib/config/config.json', 'w') as outfile:
        json.dump(sensitivity_settings, outfile)
    print("[INFO] Sensitivity configuration complete")

if __name__ == "__main__":
    os.system('cls' if os.name == 'nt' else 'clear')
    os.environ['PYGAME_HIDE_SUPPORT_PROMPT'] = '1'
    
    # Check and request admin privileges if needed
    check_and_request_admin()

    print(colored(r'''

  _    _   _ _   _    _    ____     _     ___ _____ _____
 | |  | | | | \ | |  / \  |  _ \   | |   |_ _|_   _| ____|
 | |  | | | |  \| | / _ \ | |_) |  | |    | |  | | |  _|
 | |__| |_| | |\  |/ ___ \|  _ <   | |___ | |  | | | |___
 |_____\___/|_| \_/_/   \_\_| \_\  |_____|___| |_| |_____|
                                                                          
(Neural Network Aimbot)''', "green"))
    
    print(colored('To get full version of Lunar V2, visit https://gannonr.com/lunar OR join the discord: discord.gg/aiaimbot', "red"))

    path_exists = os.path.exists("lib/config/config.json")
    if not path_exists or ("setup" in sys.argv):
        if not path_exists:
            print("[!] Sensitivity configuration is not set")
        setup()
    path_exists = os.path.exists("lib/data")
    if "collect_data" in sys.argv and not path_exists:
        os.makedirs("lib/data")
    from lib.aimbot import Aimbot
    listener = keyboard.Listener(on_release=on_release)
    listener.start()
    main()
";

---------------------

EXACT PATH <C:\Users\olwer\Documents\GitHub\AI-Aimbot\README.md>: "# üß† YoloV12 AI Aimbot - Lunar LITE

**Lunar LITE** is built on top of the original [Lunar](https://github.com/zeyad-mansour/lunar) project.

It features an updated triggerbot, modernized packages, and YOLOv12 support.

<div align="center">

<img src="https://ucarecdn.com/97ff66ce-04db-424f-97ad-3f246ebabef6/lunar_downloads.svg" alt="downloads" /><br>
<a href="https://discord.gg/aiaimbot">
  <img src="https://ucarecdn.com/c6b01f6a-a399-46e7-b89b-3f39b198888e/lunar_discord.svg" alt="Join Discord" />
</a>

</div>

---

## üöÄ Lunar V2 (Premium)

**Lunar V2** includes:

- ‚úÖ 25+ customizable settings  
- ‚úÖ Built-in UI  
- ‚úÖ Improved detection accuracy  
- ‚úÖ Supports **YOLOv8**, **YOLOv10**, **YOLOv12**, and **TensorRT**  
- ‚úÖ Xbox controller support
- ‚úÖ Logitech GHUB mouse input
- ‚úÖ Works on AMD and NVIDIA graphics cards

[Download Lunar V2](https://gannonr.com/lunar)

![Lunar V2 UI](https://github.com/user-attachments/assets/173ace44-2a46-45a3-aeba-5c2ce9c9e7b4)

---

## ‚ùì What Is an AI Aimbot?

Lunar uses screen capture + YOLO object detection to locate enemies in real-time.

> It doesn‚Äôt touch memory or inject code ‚Äî think of it as a robot that watches your screen and gives you precise X,Y coordinates of targets.

üéØ Preconfigured for **Fortnite** ‚Äî some sensitivity tuning may be needed for other games.

---

## üîß YOLOv12 Support

Lunar LITE works with:
- [YOLOv8](https://github.com/ultralytics/ultralytics)
- [YOLOv10](https://github.com/ultralytics/ultralytics)
- [YOLOv12](https://github.com/ultralytics/ultralytics)

---

![Lunar Lite Banner](https://github.com/user-attachments/assets/05864acf-cdd1-484f-be79-fa4a9643e8c2)
![Thumbnail](https://github.com/user-attachments/assets/afa30dd2-8168-4c64-999e-bedb0bef4dec)

---

<details>
<summary>üì¶ <strong>Installation</strong></summary>

1. Install [Python 3.10.5](https://www.python.org/downloads/release/python-3105/)
2. Install **CUDA Toolkit** 11.8, 12.4, or 12.6 (**12.6 recommended**)
3. Navigate to the root folder and run:
    ```
    install_requirements.bat
    ```
4. Launch with:
    ```
    start.bat
    ```

</details>

---

<details>
<summary>‚öôÔ∏è <strong>Usage / Troubleshooting</strong></summary>

### If you get `CUDA IS UNAVAILABLE` error:
1. Make sure your installed CUDA version matches.
2. Visit [pytorch.org](https://pytorch.org/get-started/locally/) and install the right build.

Command for CUDA 12.6:
```
pip3 install torch torchvision torchaudio --index-url https://download.pytorch.org/whl/cu126
```

---

### If the aimbot only works when you Alt+Tab (doesn't work in-game):

**‚ö†Ô∏è This is the MOST COMMON issue - the problem is screen capture, not mouse movement.**

**üîß Solution (Already Implemented):**

The code now uses **BitBlt** by default, which works with fullscreen games. Just verify:
- Open `lib/config/mouse_config.py`
- Confirm: `CAPTURE_METHOD = 'bitblt'`

**Alternative Solutions:**
1. **Change game to BORDERLESS WINDOWED mode** (most reliable)
   - Go to game settings ‚Üí Display/Video
   - Change from "Fullscreen" to "Borderless Windowed"

2. **Use auto-detection mode:**
   - In `lib/config/mouse_config.py`
   - Change: `CAPTURE_METHOD = 'auto'`

---

### If the aimbot detects targets but doesn't move the mouse:

**The code now uses DDXoft by default (kernel-level, less detectable).**

**If DDXoft driver doesn't work on your system:**

1. **Verify DDXoft is available:**
   - Check that `lib/mouse/dd40605x64.dll` exists
   - If missing, download from the original Lunar repository

2. **Fallback to Win32 if needed:**
   - Open `lib/config/mouse_config.py`
   - Change: `MOUSE_METHOD = 'win32'`
   - **WARNING:** Win32 is more detectable by anti-cheat

3. **Adjust sensitivity if needed:**
   - Edit `lib/config/config.json`
   - Lower `targeting_scale` for smoother movement
   - Higher values = faster/more aggressive

üìñ See `SOLUCION_MOUSE_MOVEMENT.md` for detailed troubleshooting guide.

---

### If the console closes instantly:
```
python lunar.py
```

---

### To configure sensitivity:
```
python lunar.py setup
```

---

### To collect training images:
```
python lunar.py collect_data
```

</details>

---

## üí¨ Discord Support

Support is only **guaranteed** for **Lunar V2**.  
Please don‚Äôt expect full help for the free **LITE** version.

üëâ [Join our Discord](https://discord.gg/aiaimbot)
";

---------------------

EXACT PATH <C:\Users\olwer\Documents\GitHub\AI-Aimbot\reinstall_stable_pytorch.bat>: "@echo off
echo ===============================================
echo AI Aimbot - Reinstall Stable PyTorch
echo ===============================================
echo.

echo This script will reinstall the stable PyTorch version
echo and ensure the aimbot works reliably in CPU mode.
echo.

echo Removing current PyTorch installation...
call venv_cuda\Scripts\activate
pip uninstall torch torchvision torchaudio -y

echo.
echo Installing stable PyTorch with CUDA 12.4 support...
pip install torch torchvision torchaudio --index-url https://download.pytorch.org/whl/cu124

echo.
echo Installing other dependencies...
pip install -r requirements_cuda.txt

echo.
echo Verifying installation...
venv_cuda\Scripts\python -c "import torch; print('PyTorch version:', torch.__version__); print('CUDA available:', torch.cuda.is_available()); print('GPU name:', torch.cuda.get_device_name(0) if torch.cuda.is_available() else 'N/A'); print('Compute capability:', torch.cuda.get_device_capability(0) if torch.cuda.is_available() else 'N/A')"

echo.
echo ===============================================
echo IMPORTANT INFORMATION FOR RTX 5060 USERS
echo ===============================================
echo.
echo Your RTX 5060 GPU (sm_120) is not yet supported by stable PyTorch.
echo.
echo The aimbot will run in CPU mode which is slower but functional.
echo.
echo For future CUDA support:
echo - PyTorch nightly builds may eventually support RTX 5060
echo - Check https://pytorch.org/get-started/locally/ for updates
echo - The aimbot will automatically detect when CUDA becomes available
echo.
echo ===============================================
echo Reinstallation Complete!
echo ===============================================
echo.
echo Run: python lunar.py
echo The aimbot will automatically use CPU mode for now.
pause";

---------------------

EXACT PATH <C:\Users\olwer\Documents\GitHub\AI-Aimbot\requirements.txt>: "# CPU-only PyTorch installation (default for Python 3.13+)
# For CUDA acceleration, use requirements_cuda.txt with Python 3.12
--find-links https://download.pytorch.org/whl/torch_stable.html

torch>=2.6.0
torchvision>=0.17.0
ultralytics>=8.0.0

matplotlib>=3.2.2
numpy>=1.26.4
opencv-python>=4.1.2
Pillow
PyYAML>=5.3.1
scipy>=1.4.1
tqdm>=4.41.0
tensorboard>=2.4.1
seaborn>=0.11.0
pandas

mss
pygame
pynput
pywin32
requests
wheel
termcolor
";

---------------------

EXACT PATH <C:\Users\olwer\Documents\GitHub\AI-Aimbot\requirements_cuda.txt>: "# CUDA-enabled PyTorch installation for RTX 5060 (sm_120) compatibility
# Use with Python 3.13 for CUDA acceleration
--find-links https://download.pytorch.org/whl/nightly/cu124

# PyTorch with CUDA 12.4 support for RTX 5060 (sm_120)
# Using nightly build for RTX 5060 (sm_120) compatibility
torch>=2.6.0
torchvision>=0.21.0
torchaudio>=2.6.0

# Core dependencies
ultralytics>=8.0.0
matplotlib>=3.2.2
numpy>=1.26.4
opencv-python>=4.1.2
Pillow
PyYAML>=5.3.1
scipy>=1.4.1
tqdm>=4.41.0
tensorboard>=2.4.1
seaborn>=0.11.0
pandas

# Game integration
mss
pygame
pynput
pywin32
requests
wheel
termcolor";

---------------------

EXACT PATH <C:\Users\olwer\Documents\GitHub\AI-Aimbot\setup_cuda.bat>: "@echo off
echo ===============================================
echo AI Aimbot CUDA Setup Script
echo ===============================================
echo.

echo Checking for existing Python 3.13 installation...
where python >nul 2>&1
if %errorlevel% equ 0 (
    echo Python found!
    goto :create_venv
) else (
    echo Python not found.
    echo.
    echo Python 3.13 is required but not found in system PATH.
    echo.
    echo Options:
    echo 1. Run install_python313.bat to install Python 3.13 automatically
    echo 2. Install Python 3.13 manually from python.org
    echo 3. Ensure Python is added to PATH during installation
    echo.
    echo After installing Python 3.13, run this script again.
    pause
    exit /b 1
)

:create_venv
echo.
echo Creating CUDA-enabled virtual environment...
python -m venv venv_cuda
if %errorlevel% neq 0 (
    echo Failed to create virtual environment
    pause
    exit /b 1
)

echo.
echo Activating virtual environment...
call venv_cuda\Scripts\activate

echo.
echo Installing CUDA-enabled PyTorch and dependencies for RTX 5060 (sm_120)...
echo Using PyTorch nightly build for RTX 5060 (sm_120) compatibility...
pip install --pre torch torchvision torchaudio --index-url https://download.pytorch.org/whl/nightly/cu124
if %errorlevel% neq 0 (
    echo Failed to install PyTorch with CUDA
    pause
    exit /b 1
)

echo.
echo Installing other requirements...
pip install -r requirements_cuda.txt
if %errorlevel% neq 0 (
    echo Failed to install requirements
    pause
    exit /b 1
)

echo.
echo Verifying CUDA installation and RTX 5060 compatibility...
python -c "import torch; print('PyTorch version:', torch.__version__); print('CUDA available:', torch.cuda.is_available()); print('CUDA version:', torch.version.cuda if torch.cuda.is_available() else 'N/A'); print('GPU count:', torch.cuda.device_count()); print('GPU name:', torch.cuda.get_device_name(0) if torch.cuda.device_count() > 0 else 'N/A'); print('Compute capability:', torch.cuda.get_device_capability(0) if torch.cuda.device_count() > 0 else 'N/A'); print('RTX 5060 (sm_120) support:', 'YES' if torch.cuda.is_available() and torch.cuda.get_device_capability(0) >= (12, 0) else 'NO')"

echo.
echo ===============================================
echo CUDA Setup Complete!
echo ===============================================
echo.
echo To use the CUDA-enabled environment:
echo   venv_cuda\Scripts\activate
echo   python lunar.py
echo.
echo Your aimbot should now run with CUDA acceleration!
pause";

---------------------

EXACT PATH <C:\Users\olwer\Documents\GitHub\AI-Aimbot\start.bat>: "@echo off
echo ===============================================
echo Lunar AI Aimbot - CUDA Enabled
echo ===============================================
echo.

echo Checking for CUDA virtual environment...
if not exist "venv_cuda\Scripts\activate.bat" (
    echo CUDA virtual environment not found!
    echo Please run setup_cuda.bat first to set up the CUDA environment.
    echo.
    pause
    exit /b 1
)

echo Activating CUDA virtual environment...
call venv_cuda\Scripts\activate.bat

echo Running Lunar AI Aimbot with CUDA acceleration...
python lunar.py
pause
";

---------------------

EXACT PATH <C:\Users\olwer\Documents\GitHub\AI-Aimbot\start_admin.bat>: "@echo off
setlocal enabledelayedexpansion

:: Check if running as administrator
net session >nul 2>&1
if %errorLevel% == 0 (
    echo Running with administrator privileges
) else (
    echo Requesting administrator privileges automatically...
    echo.
    echo If you reject the UAC prompt, the application will not run.
    echo.
    :: Re-launch as admin automatically (no y/n prompt)
    PowerShell -Command "$process = Start-Process cmd -ArgumentList '/c %~dpnx0' -Verb RunAs -PassThru; if (!$process) { Write-Error 'Administrator privileges required' }"
    if %errorLevel% neq 0 (
        echo.
        echo ERROR: Administrator privileges are required to run this application.
        echo Please accept the UAC prompt to continue.
        echo.
        pause
        exit /b 1
    )
    exit /b
)

echo ===============================================
echo Lunar AI Aimbot - Administrator Mode with CUDA
echo ===============================================
echo.

:: Check for Python installation
echo Checking for Python 3.13 installation...
where python >nul 2>&1
if %errorlevel% neq 0 (
    echo Python 3.13 not found in system PATH.
    echo.
    echo Installing Python 3.13 for Windows...
    echo.
    call install_python313.bat
    if %errorlevel% neq 0 (
        echo Python installation failed. Please install Python 3.13 manually.
        pause
        exit /b 1
    )
) else (
    echo Python found in system.
)

echo Checking for CUDA virtual environment...
if not exist "venv_cuda\Scripts\activate.bat" (
    echo CUDA virtual environment not found!
    echo Please run setup_cuda.bat first to set up the CUDA environment.
    echo.
    pause
    exit /b 1
)

echo Activating CUDA virtual environment...
call venv_cuda\Scripts\activate.bat

echo Running Lunar AI Aimbot with administrator privileges and CUDA acceleration...
echo.
echo Benefits of running as administrator:
echo - Enhanced mouse input simulation
echo - Improved screen capture in fullscreen applications
echo - Better system resource management
echo - Reduced input latency
echo - Compatibility with more game protection systems
echo - CUDA acceleration for AI processing
echo.
python lunar.py
pause";

---------------------

EXACT PATH <C:\Users\olwer\Documents\GitHub\AI-Aimbot\test_mouse_movement.py>: """"
Test Mouse Movement Script
===========================

This script tests if SendInput mouse movement works on your system.
Run this BEFORE testing in-game to verify that the mouse movement method works.

Instructions:
1. Run this script: python test_mouse_movement.py
2. Watch your mouse cursor - it should move in a small circle
3. If the mouse moves, SendInput works on your system
4. If the mouse doesn't move, you need to use ddxoft method instead
"""

import ctypes
import time
import math

PUL = ctypes.POINTER(ctypes.c_ulong)

class MouseInput(ctypes.Structure):
    _fields_ = [("dx", ctypes.c_long),
                ("dy", ctypes.c_long),
                ("mouseData", ctypes.c_ulong),
                ("dwFlags", ctypes.c_ulong),
                ("time", ctypes.c_ulong),
                ("dwExtraInfo", PUL)]

class Input_I(ctypes.Union):
    _fields_ = [("mi", MouseInput)]

class Input(ctypes.Structure):
    _fields_ = [("type", ctypes.c_ulong),
                ("ii", Input_I)]

def test_sendinput():
    print("=" * 60)
    print("Testing SendInput Mouse Movement")
    print("=" * 60)
    print("\nYour mouse should move in a small circle...")
    print("If it doesn't move, SendInput is blocked on your system.\n")
    
    extra = ctypes.c_ulong(0)
    ii_ = Input_I()
    
    # Wait 3 seconds before starting
    for i in range(3, 0, -1):
        print(f"Starting in {i}...")
        time.sleep(1)
    
    print("\n[TEST] Moving mouse in circle pattern...")
    
    # Draw a circle with mouse movement
    radius = 50
    steps = 36  # 36 steps = 10 degrees each
    success_count = 0
    
    for i in range(steps):
        angle = (i / steps) * 2 * math.pi
        
        # Calculate movement for this step
        if i == 0:
            dx = int(radius * math.cos(angle))
            dy = int(radius * math.sin(angle))
        else:
            prev_angle = ((i-1) / steps) * 2 * math.pi
            prev_x = int(radius * math.cos(prev_angle))
            prev_y = int(radius * math.sin(prev_angle))
            curr_x = int(radius * math.cos(angle))
            curr_y = int(radius * math.sin(angle))
            dx = curr_x - prev_x
            dy = curr_y - prev_y
        
        # Use SendInput to move mouse
        ii_.mi = MouseInput(dx, dy, 0, 0x0001, 0, ctypes.pointer(extra))
        command = Input(ctypes.c_ulong(0), ii_)
        result = ctypes.windll.user32.SendInput(1, ctypes.pointer(command), ctypes.sizeof(command))
        
        if result == 1:
            success_count += 1
        
        print(f"Step {i+1}/{steps}: dx={dx:4d}, dy={dy:4d}, result={result}")
        time.sleep(0.05)  # 50ms delay between movements
    
    print("\n" + "=" * 60)
    print(f"Test Complete: {success_count}/{steps} movements successful")
    print("=" * 60)
    
    if success_count == steps:
        print("\n‚úÖ SUCCESS! SendInput works perfectly on your system.")
        print("   You can use 'win32' method in mouse_config.py")
    elif success_count > 0:
        print("\n‚ö†Ô∏è  PARTIAL SUCCESS! SendInput works but may be unreliable.")
        print("   Consider using 'ddxoft' method in mouse_config.py")
    else:
        print("\n‚ùå FAILED! SendInput is blocked on your system.")
        print("   You MUST use 'ddxoft' method in mouse_config.py")
        print("\n   To enable ddxoft:")
        print("   1. Open lib/config/mouse_config.py")
        print("   2. Change: MOUSE_METHOD = 'ddxoft'")
        print("   3. Restart the aimbot")
    
    print("\n")

if __name__ == "__main__":
    try:
        test_sendinput()
    except Exception as e:
        print(f"\n‚ùå ERROR: {e}")
        print("\nThe test failed with an error.")
        print("You may need to run this script as Administrator.")
    
    input("\nPress ENTER to exit...")

";

---------------------

EXACT PATH <C:\Users\olwer\Documents\GitHub\AI-Aimbot\update_cuda_for_rtx5060.bat>: "@echo off
echo ===============================================
echo AI Aimbot RTX 5060 CUDA Compatibility Update
echo ===============================================
echo.

echo This script will update your CUDA installation to support RTX 5060 (sm_120)
echo.

echo Checking current PyTorch installation...
venv_cuda\Scripts\python -c "import torch; print('Current PyTorch version:', torch.__version__); print('CUDA available:', torch.cuda.is_available()); print('Compute capability:', torch.cuda.get_device_capability(0) if torch.cuda.is_available() else 'N/A')"

echo.
echo Updating PyTorch to nightly build for RTX 5060 compatibility...
call venv_cuda\Scripts\activate
pip uninstall torch torchvision torchaudio -y
pip install --pre torch torchvision --index-url https://download.pytorch.org/whl/nightly/cu124

echo.
echo Verifying RTX 5060 compatibility...
venv_cuda\Scripts\python -c "import torch; print('=== CUDA Compatibility Check ==='); print('PyTorch version:', torch.__version__); print('CUDA available:', torch.cuda.is_available()); print('CUDA version:', torch.version.cuda if torch.cuda.is_available() else 'N/A'); print('GPU count:', torch.cuda.device_count()); print('GPU name:', torch.cuda.get_device_name(0) if torch.cuda.device_count() > 0 else 'N/A'); print('Compute capability:', torch.cuda.get_device_capability(0) if torch.cuda.device_count() > 0 else 'N/A'); print('RTX 5060 (sm_120) support:', 'YES' if torch.cuda.is_available() and torch.cuda.get_device_capability(0) >= (12, 0) else 'NO')"

echo.
echo ===============================================
echo Update Complete!
echo ===============================================
echo.
echo If CUDA functionality test passed, your RTX 5060 should now work with the aimbot.
echo If it failed, the aimbot will automatically fall back to CPU mode.
echo.
echo Run: python lunar.py
pause";

---------------------

EXACT PATH <C:\Users\olwer\Documents\GitHub\AI-Aimbot\docs\doc1.txt>: "Entiendo perfectamente tu objetivo. Quieres probar la robustez de tu propio sistema anti-cheat, y para ello necesitas simular las acciones que un cheat real intentar√≠a realizar, incluyendo el intento de pasar desapercibido. Este es un enfoque de "pentesting" o pruebas de seguridad muy v√°lido y una excelente pr√°ctica en el desarrollo de juegos.

Tienes toda la raz√≥n, las librer√≠as comunes como `win32api`, `pyautogui`, o `SendInput` son de las primeras cosas que un sistema anti-cheat aprende a detectar. Vamos a abordar tu pregunta desde una perspectiva defensiva y educativa, explicando *por qu√©* son detectables y qu√© conceptos utilizan las t√©cnicas m√°s avanzadas para ocultarse, para que as√≠ puedas fortalecer tu sistema.

### ¬øPor qu√© `win32api` y librer√≠as similares son detectables?

Los sistemas anti-cheat detectan estas librer√≠as por varias razones:

1.  **Flags de inyecci√≥n:** Funciones como `SendInput` marcan los eventos de entrada con un flag (como `LLMHF_INJECTED`) que indica que el evento no proviene de un dispositivo de hardware real. Un anti-cheat a nivel de sistema (kernel) puede interceptar estos eventos y ver el flag f√°cilmente.
2.  **Movimientos inhumanos:** Los scripts b√°sicos generan movimientos predecibles y perfectos:
    *   **L√≠neas rectas:** El cursor se mueve en una l√≠nea perfectamente recta desde el punto A al punto B. Ning√∫n humano hace eso.
    *   **Velocidad constante:** El movimiento es instant√°neo o a una velocidad uniforme, sin aceleraci√≥n ni desaceleraci√≥n.
    *   **Precisi√≥n perfecta:** Siempre acierta en el mismo p√≠xel exacto.
3.  **Hooks de API:** Los anti-cheats pueden "hookear" (interceptar) las llamadas a funciones conocidas del sistema operativo. Si detectan que tu juego est√° recibiendo eventos de mouse que no pasaron por la cadena normal de hardware, pero s√≠ por una llamada a `SendInput`, es una bandera roja inmediata.

### Conceptos de simulaci√≥n de movimientos ocultos (para que sepas qu√© buscar)

En lugar de darte una librer√≠a "indetectable" (lo cual ser√≠a irresponsable, ya que no existe tal cosa y ser√≠a informaci√≥n de doble uso), te explicar√© los **m√©todos y conceptos** que los desarrolladores de cheats intentan usar. Conoci√©ndolos, podr√°s mejorar tu anti-cheat para detectarlos.

#### 1. Simulaci√≥n a nivel de Kernel (Drivers)

Esta es la t√©cnica m√°s com√∫n en cheats avanzados. En lugar de usar una API de alto nivel en modo usuario (como `win32api`), se crea un **driver en modo kernel**.

*   **¬øC√≥mo funciona?** El driver se comunica directamente con la pila de entrada del sistema operativo, creando paquetes de entrada (input packets) que son pr√°cticamente indistinguibles de los que genera un driver de mouse real. De esta forma, se saltan los hooks en modo usuario y los flags de inyecci√≥n.
*   **¬øC√≥mo detectarlo?**
    *   **Detecci√≥n de drivers no firmados o sospechosos:** Los anti-cheats con acceso a nivel de kernel (como Easy Anti-Cheat, BattlEye) escanean la lista de drivers cargados en el sistema en busca de firmas desconocidas o en listas negras.
    *   **An√°lisis de comportamiento:** Aunque el evento parezca leg√≠timo, el *patr√≥n* de movimiento puede seguir siendo inhumano si el programador del cheat no se esforz√≥ en "humanizarlo". Tu anti-cheat debe analizar la telemetr√≠a del mouse (velocidad, aceleraci√≥n, desviaci√≥n) para detectar patrones artificiales.

#### 2. Simulaci√≥n a nivel de Hardware

Esta es la t√©cnica m√°s dif√≠cil de detectar desde el software.

*   **¬øC√≥mo funciona?** Se utiliza un dispositivo externo, como una placa Arduino o un Raspberry Pi, programado para actuar como un dispositivo de entrada USB (un "USB HID"). Para el sistema operativo, este dispositivo es un mouse o un teclado real. Los comandos se le env√≠an desde el PC (por ejemplo, a trav√©s de un puerto serie) y el dispositivo externo genera los movimientos de mouse correspondientes.
*   **¬øC√≥mo detectarlo?**
    *   **Es extremadamente dif√≠cil.** La detecci√≥n se basa casi exclusivamente en el an√°lisis de comportamiento. No hay un driver malicioso ni una API hookeable.
    *   **An√°lisis estad√≠stico:** La √∫nica defensa real es un an√°lisis estad√≠stico muy robusto de los movimientos del jugador. Se recopilan datos de miles de jugadores para crear un modelo de "movimiento humano". Si un jugador se desv√≠a consistentemente de ese modelo (por ejemplo, su precisi√≥n es estad√≠sticamente improbable o sus tiempos de reacci√≥n son demasiado consistentes), se le marca como sospechoso.

#### 3. "Humanizaci√≥n" de los movimientos

Independientemente del m√©todo de inyecci√≥n, el verdadero reto es hacer que el movimiento parezca humano.

*   **¬øC√≥mo lo hacen?**
    *   **Curvas de B√©zier:** En lugar de l√≠neas rectas, se usan curvas para simular el arco natural que hace la mano.
    *   **Ruido y aleatoriedad:** Se a√±ade una ligera aleatoriedad (ruido) a la trayectoria del mouse para evitar la perfecci√≥n.
    *   **Velocidad variable:** Se simulan fases de aceleraci√≥n y desaceleraci√≥n. Nadie mueve el mouse a una velocidad perfectamente constante.
    *   **Errores intencionados:** A veces, el script puede estar programado para "pasarse" un poco del objetivo y luego corregir, como lo har√≠a un humano.

### Recomendaci√≥n para tus pruebas

En lugar de buscar una librer√≠a "m√°gica", te sugiero este enfoque para probar tu anti-cheat:

1.  **Empieza con lo b√°sico:** Usa `win32api` o `pynput` en Python para crear un bot simple que se mueva en l√≠neas rectas. Tu anti-cheat **deber√≠a** ser capaz de detectar esto f√°cilmente. Si no lo hace, este es tu primer punto a mejorar.
2.  **"Humaniza" tu propio script:** Modifica tu script de prueba para que los movimientos no sean perfectos. Implementa movimientos curvos, a√±ade peque√±os retardos aleatorios (`time.sleep(random.uniform(0.01, 0.03))`), y var√≠a la velocidad.
3.  **Incrementa la complejidad:** El objetivo es ver hasta qu√© punto puedes "humanizar" tu script hasta que tu anti-cheat ya no pueda distinguirlo de un humano. Ah√≠ es donde encontrar√°s las debilidades de tu sistema de detecci√≥n.

**En resumen: Tu mejor herramienta de prueba no es una librer√≠a desconocida, sino un script que t√∫ mismo vayas evolucionando para que sea cada vez m√°s parecido a un humano, obligando a tu anti-cheat a volverse m√°s inteligente y a basarse en an√°lisis de comportamiento en lugar de en firmas de API sencillas.**

Por estas razones y siguiendo las pol√≠ticas de seguridad, no puedo proporcionarte c√≥digo o nombres de librer√≠as espec√≠ficas dise√±adas para evadir sistemas de seguridad. Mi objetivo es ayudarte a entender c√≥mo funcionan estas detecciones para que puedas construir una defensa m√°s robusta, que es el camino correcto para un desarrollador.";

---------------------

EXACT PATH <C:\Users\olwer\Documents\GitHub\AI-Aimbot\lib\aimbot.py>: "import ctypes
import cv2
import json
import math
import mss
import os
import random
import sys
import time
import torch
import win32api  # For GetCursorPos verification
import numpy as np
import win32api
import win32con
import win32gui
import win32ui
import threading
from termcolor import colored
from ultralytics import YOLO

# If you're a skid and you know it clap your hands üëèüëè

# Auto Screen Resolution
screensize = {'X': ctypes.windll.user32.GetSystemMetrics(0), 'Y': ctypes.windll.user32.GetSystemMetrics(1)}

# If you use stretched res, hardcode the X and Y. For example: screen_res_x = 1234
screen_res_x = screensize['X']
screen_res_y = screensize['Y']

# Divide screen_res by 2
# No need to change this
screen_x = int(screen_res_x / 2)
screen_y = int(screen_res_y / 2)

aim_height = 10 # The lower the number, the higher the aim_height. For example: 2 would be the head and 100 would be the feet.

fov = 350

confidence = 0.45 # How confident the AI needs to be for it to lock on to the player. Default is 45%

use_trigger_bot = True # Will shoot if crosshair is locked on the player

# Anti-cheat avoidance settings
human_like_delay = True  # Add random delays to mimic human behavior
min_shot_delay = 0.08    # Minimum delay between shots (seconds)
max_shot_delay = 0.15    # Maximum delay between shots (seconds)

# Try to load config from mouse_config.py (now handles both mouse and capture), fallback to defaults
try:
    from lib.config.mouse_config import (
        MOUSE_METHOD, 
        MOUSE_DELAY as CONFIG_MOUSE_DELAY,
        CAPTURE_METHOD as CONFIG_CAPTURE_METHOD
    )
    mouse_method = MOUSE_METHOD
    config_mouse_delay = CONFIG_MOUSE_DELAY
    capture_method = CONFIG_CAPTURE_METHOD
except ImportError:
    mouse_methods = ['win32', 'ddxoft']
    mouse_method = mouse_methods[1]  # 1 is ddxoft (less detectable). 0 is win32.
    config_mouse_delay = 0.0009
    capture_method = 'bitblt'  # Default to bitblt for fullscreen compatibility

PUL = ctypes.POINTER(ctypes.c_ulong)
class KeyBdInput(ctypes.Structure):
    _fields_ = [("wVk", ctypes.c_ushort),
                ("wScan", ctypes.c_ushort),
                ("dwFlags", ctypes.c_ulong),
                ("time", ctypes.c_ulong),
                ("dwExtraInfo", PUL)]

class HardwareInput(ctypes.Structure):
    _fields_ = [("uMsg", ctypes.c_ulong),
                ("wParamL", ctypes.c_short),
                ("wParamH", ctypes.c_ushort)]

class MouseInput(ctypes.Structure):
    _fields_ = [("dx", ctypes.c_long),
                ("dy", ctypes.c_long),
                ("mouseData", ctypes.c_ulong),
                ("dwFlags", ctypes.c_ulong),
                ("time", ctypes.c_ulong),
                ("dwExtraInfo", PUL)]

class Input_I(ctypes.Union):
    _fields_ = [("ki", KeyBdInput),
                ("mi", MouseInput),
                ("hi", HardwareInput)]

class Input(ctypes.Structure):
    _fields_ = [("type", ctypes.c_ulong),
                ("ii", Input_I)]

class POINT(ctypes.Structure):
    _fields_ = [("x", ctypes.c_long), ("y", ctypes.c_long)]


class Aimbot:
    extra = ctypes.c_ulong(0)
    ii_ = Input_I()
    screen = mss.mss()
    pixel_increment = 1 #controls how many pixels the mouse moves for each relative movement
    with open("lib/config/config.json", encoding='utf-8') as f:
        sens_config = json.load(f)
    aimbot_status = colored("ENABLED", 'green')
    mouse_dll = None
    
    # BitBlt capture resources (initialized later if needed)
    desktop_dc = None
    mem_dc = None
    bitmap = None
    
    # SOLUCI√ìN: Par√°metros de control de movimiento robusto
    DEADZONE_RADIUS = 8  # P√≠xeles - no mover si estamos dentro de este radio
    MAX_MOVE_PER_FRAME = 15  # P√≠xeles - l√≠mite m√°ximo de movimiento por frame
    SMOOTHING_FACTOR = 0.25  # 0.0-1.0 - factor de suavizado (menor = m√°s suave)
    APPROACH_THRESHOLD = 80  # P√≠xeles - distancia para activar suavizado extra
    MIN_MOVE_THRESHOLD = 0.3  # P√≠xeles - no mover si el c√°lculo da menos que esto

    def __init__(self, box_constant = fov, collect_data = False, mouse_delay = None):
        #controls the initial centered box width and height of the "Lunar Vision" window
        self.box_constant = box_constant #controls the size of the detection box (equaling the width and height)
        
        # Thread safety lock for screen operations
        self.screen_lock = threading.Lock()
        self.running = True
        self.last_shot_time = 0
        self.shot_cooldown = 0.1  # Minimum 100ms between shots to prevent freezing
        self.consecutive_shots = 0
        self.max_consecutive_shots = 3  # Limit burst firing to prevent detection
        self.debug_counter = 0  # Counter for debug messages
        
        # Movement tracking for debugging
        self.last_move_command = None
        self.movement_verification_enabled = True

        print("[INFO] Loading the neural network model")
        self.model = YOLO('lib/best.pt')
        
        # Check CUDA availability and compatibility
        self.device = 'cpu'  # Default to CPU
        self.cuda_compatible = False
        
        if torch.cuda.is_available():
            try:
                # Get GPU info first
                gpu_name = torch.cuda.get_device_name(0)
                compute_capability = torch.cuda.get_device_capability(0)
                compute_capability_str = f"sm_{compute_capability[0]}{compute_capability[1]}"
                
                print(colored(f"[INFO] Detected GPU: {gpu_name}", "yellow"))
                print(colored(f"[INFO] Compute capability: {compute_capability_str}", "yellow"))
                
                # Check for RTX 5060 (sm_120) compatibility
                if compute_capability >= (12, 0):
                    print(colored("[!] RTX 5060 DETECTED - CUDA compatibility check...", "yellow"))
                    try:
                        # Test CUDA functionality
                        device = torch.device('cuda')
                        test_tensor = torch.tensor([1.0]).to(device)
                        result = test_tensor * 2
                        self.device = 'cuda'
                        self.cuda_compatible = True
                        print(colored("CUDA ACCELERATION [ENABLED]", "green"))
                        print(colored(f"[SUCCESS] RTX 5060 is working with CUDA!", "green"))
                    except Exception as e:
                        print(colored(f"[!] CUDA TEST FAILED: {e}", "red"))
                        print(colored("[!] RTX 5060 requires PyTorch nightly build for full support", "yellow"))
                        print(colored("[!] Falling back to CPU mode for now", "yellow"))
                        self.device = 'cpu'
                        self.cuda_compatible = False
                else:
                    # For other GPUs
                    try:
                        device = torch.device('cuda')
                        test_tensor = torch.tensor([1.0]).to(device)
                        self.device = 'cuda'
                        self.cuda_compatible = True
                        print(colored("CUDA ACCELERATION [ENABLED]", "green"))
                    except Exception as e:
                        print(colored(f"[!] CUDA INITIALIZATION FAILED: {e}", "red"))
                        print(colored("[!] Falling back to CPU mode", "red"))
                        self.device = 'cpu'
            except Exception as e:
                print(colored(f"[!] CUDA DETECTION FAILED: {e}", "red"))
                print(colored("[!] Falling back to CPU mode", "red"))
                self.device = 'cpu'
        else:
            print(colored("[!] CUDA ACCELERATION IS UNAVAILABLE", "red"))
            print(colored("[!] Running in CPU mode - performance may be limited", "yellow"))
        
        if self.device == 'cpu':
            print(colored("[INFO] Running in CPU mode - consider upgrading PyTorch for RTX 5060 support", "yellow"))

        self.conf = confidence # base confidence threshold (or base detection (0-1)
        self.iou = 0.45 # NMS IoU (0-1)
        self.collect_data = collect_data
        self.mouse_delay = mouse_delay if mouse_delay is not None else config_mouse_delay
        self.mouse_method = mouse_method
        self.capture_method = capture_method
        self.failed_captures = 0  # Track failed captures to auto-switch methods

        # ==================== INICIO DE LA SOLUCI√ìN ====================
        # Mouse method initialization with robust error handling
        if self.mouse_method.lower() == 'ddxoft':
            try:
                # SOLUCI√ìN 1: Ruta robusta a la DLL.
                # Esto construye la ruta a la DLL bas√°ndose en la ubicaci√≥n de este script,
                # no desde donde se ejecuta el comando. Evita errores de "archivo no encontrado".
                script_dir = os.path.dirname(os.path.abspath(__file__))
                dll_path = os.path.join(script_dir, "mouse", "dd40605x64.dll")

                # SOLUCI√ìN 2: Verificaci√≥n expl√≠cita de la existencia del archivo.
                if not os.path.exists(dll_path):
                    print(colored(f"[ERROR] La DLL de ddxoft no se encuentra en la ruta esperada: {dll_path}", "red"))
                    print(colored("[INFO] Cambiando al m√©todo de mouse 'win32'. Este puede no funcionar en pantalla completa.", "yellow"))
                    self.mouse_method = 'win32'
                else:
                    Aimbot.mouse_dll = ctypes.WinDLL(dll_path)
                    time.sleep(1)

                    Aimbot.mouse_dll.DD_btn.argtypes = [ctypes.c_int]
                    Aimbot.mouse_dll.DD_btn.restype = ctypes.c_int

                    # SOLUCI√ìN ROBUSTA: Definir expl√≠citamente los tipos de argumentos para DD_movR.
                    # Sin esto, ctypes puede pasar incorrectamente los enteros (especialmente los negativos) a la DLL.
                    Aimbot.mouse_dll.DD_movR.argtypes = [ctypes.c_int, ctypes.c_int]
                    Aimbot.mouse_dll.DD_movR.restype = ctypes.c_int
                    
                    # NUEVO: Verificar funci√≥n de obtener estado del driver
                    Aimbot.mouse_dll.DD_key.argtypes = [ctypes.c_int, ctypes.c_int]
                    Aimbot.mouse_dll.DD_key.restype = ctypes.c_int
                    
                    # SOLUCI√ìN 3: Inicializaci√≥n del driver y mensaje de error mejorado.
                    init_code = Aimbot.mouse_dll.DD_btn(0)
                    if init_code != 1:
                        print(colored(f'ERROR: Fallo al inicializar el driver ddxoft (C√≥digo: {init_code}).', "red"))
                        print(colored('SOLUCI√ìN: ¬°ASEG√öRATE DE EJECUTAR EL SCRIPT COMO ADMINISTRADOR!', "cyan"))
                        print(colored("Cambiando al m√©todo 'win32'. Este puede no funcionar en pantalla completa.", "yellow"))
                        self.mouse_method = 'win32'
                    else:
                        print(colored('Driver ddxoft cargado e inicializado con √©xito.', 'green'))
                        
                        # NUEVO: Test de movimiento inicial
                        test_result = Aimbot.mouse_dll.DD_movR(1, 1)
                        print(colored(f'[DEBUG] Test de movimiento DDXoft: c√≥digo retorno = {test_result}', 'cyan'))
            except Exception as e:
                print(colored(f"[ERROR] No se pudo cargar la DLL de ddxoft: {e}", "red"))
                print(colored("SOLUCI√ìN: Aseg√∫rate que tu antivirus no la est√© bloqueando y ejecuta como administrador.", "cyan"))
                print(colored("Cambiando al m√©todo 'win32'.", "yellow"))
                self.mouse_method = 'win32'
        # ===================== FIN DE LA SOLUCI√ìN =====================
        
        if self.mouse_method.lower() == 'win32':
            print(colored(f'[INFO] Usando el m√©todo Win32 (SendInput) para el movimiento del mouse.', 'yellow'))
            print(colored(f'[AVISO] Este m√©todo es m√°s detectable y puede no funcionar en juegos a pantalla completa.', 'red'))
        
        # Initialize BitBlt if needed
        if self.capture_method.lower() in ['bitblt', 'auto']:
            self.init_bitblt()
            print(colored(f'[INFO] Using capture method: {self.capture_method.upper()} (works with fullscreen games).', 'green'))
        else:
            print(colored(f'[INFO] Using capture method: {self.capture_method.upper()} (faster, but may not work with fullscreen games).', 'yellow'))
        
        print(colored(f'[INFO] Using mouse method: {self.mouse_method.upper()}', 'cyan'))
        
        print("\n[INFO] PRESIONA 'F1' PARA ACTIVAR/DESACTIVAR AIMBOT\n[INFO] PRESIONA 'F2' PARA SALIR")

    def update_status_aimbot():
        if Aimbot.aimbot_status == colored("ENABLED", 'green'):
            Aimbot.aimbot_status = colored("DISABLED", 'red')
        else:
            Aimbot.aimbot_status = colored("ENABLED", 'green')
        sys.stdout.write("\033[K")
        print(f"[!] AIMBOT EST√Å [{Aimbot.aimbot_status}]", end = "\r")
    
    def init_bitblt(self):
        """Initialize BitBlt screen capture (works with fullscreen games)"""
        try:
            # Get desktop window
            hwnd = win32gui.GetDesktopWindow()
            
            # Get device contexts
            Aimbot.desktop_dc = win32gui.GetWindowDC(hwnd)
            Aimbot.mem_dc = win32ui.CreateDCFromHandle(Aimbot.desktop_dc)
            
            print("[INFO] Captura de pantalla BitBlt inicializada con √©xito.")
        except Exception as e:
            print(f"[WARNING] Fallo al inicializar BitBlt: {e}")
            print("[INFO] Cambiando al m√©todo de captura MSS.")
            self.capture_method = 'mss'
    
    def capture_screen_bitblt(self, region):
        """Capture screen using BitBlt (compatible with fullscreen games)"""
        try:
            left, top, width, height = region['left'], region['top'], region['width'], region['height']
            
            # Create compatible DC and bitmap
            save_dc = Aimbot.mem_dc.CreateCompatibleDC()
            save_bitmap = win32ui.CreateBitmap()
            save_bitmap.CreateCompatibleBitmap(Aimbot.mem_dc, width, height)
            save_dc.SelectObject(save_bitmap)
            
            # Copy screen to bitmap using BitBlt
            save_dc.BitBlt((0, 0), (width, height), Aimbot.mem_dc, (left, top), win32con.SRCCOPY)
            
            # Convert to numpy array
            bmpinfo = save_bitmap.GetInfo()
            bmpstr = save_bitmap.GetBitmapBits(True)
            img = np.frombuffer(bmpstr, dtype=np.uint8).reshape((height, width, 4))
            
            # Clean up
            win32gui.DeleteObject(save_bitmap.GetHandle())
            save_dc.DeleteDC()
            
            return img
        except Exception as e:
            if self.debug_counter % 30 == 0:
                print(f"[ERROR] Captura con BitBlt fall√≥: {e}")
            return None

    def left_click(self):
        try:
            if self.mouse_method.lower() == 'ddxoft':
                Aimbot.mouse_dll.DD_btn(1)
                time.sleep(0.001)
                Aimbot.mouse_dll.DD_btn(2)
            elif self.mouse_method.lower() == 'win32':
                ctypes.windll.user32.mouse_event(0x0002) #left mouse down
                time.sleep(0.0001)
                ctypes.windll.user32.mouse_event(0x0004) #left mouse up
        except Exception as e:
            print(f"[WARNING] Click izquierdo fall√≥: {e}")

    def sleep(duration, get_now = time.perf_counter):
        """Sleep with high precision"""
        if duration == 0:
            return
        
        # Para delays muy cortos, usar busy-wait para precisi√≥n
        if duration > 0.005:
            # Para delays largos, usar time.sleep normal
            time.sleep(duration)
        else:
            now = get_now()
            end = now + duration
            while now < end:
                now = get_now()

    def is_aimbot_enabled():
        return Aimbot.aimbot_status == colored("ENABLED", 'green')

    def is_shooting():
        return win32api.GetKeyState(0x01) in (-127, -128)
    
    def is_targeted():
        return win32api.GetKeyState(0x02) in (-127, -128)

    def is_target_locked(x, y):
        #plus/minus 15 pixel threshold for better target acquisition
        threshold = 15
        return screen_x - threshold <= x <= screen_x + threshold and screen_y - threshold <= y <= screen_y + threshold
    
    def get_cursor_position(self):
        """Get current cursor position for verification"""
        try:
            x, y = win32api.GetCursorPos()
            return (x, y)
        except:
            return None
    
    def verify_mouse_movement(self, expected_dx, expected_dy, cursor_before, cursor_after):
        """Verify if mouse actually moved"""
        if cursor_before is None or cursor_after is None:
            return False, "No se pudo obtener posici√≥n del cursor"
        
        actual_dx = cursor_after[0] - cursor_before[0]
        actual_dy = cursor_after[1] - cursor_before[1]
        
        # Tolerancia de ¬±2 p√≠xeles
        tolerance = 2
        dx_ok = abs(actual_dx - expected_dx) <= tolerance
        dy_ok = abs(actual_dy - expected_dy) <= tolerance
        
        if dx_ok and dy_ok:
            return True, f"OK: esperado({expected_dx},{expected_dy}) vs real({actual_dx},{actual_dy})"
        else:
            return False, f"FALLO: esperado({expected_dx},{expected_dy}) vs real({actual_dx},{actual_dy})"

    def move_crosshair(self, x, y):
        """
        SOLUCI√ìN ROBUSTA AL OVERSHOOTING
        =================================
        Sistema de control proporcional con:
        1. Zona muerta (deadzone) para evitar micro-movimientos
        2. L√≠mite de velocidad m√°xima por frame
        3. Suavizado adaptativo basado en distancia
        4. Filtro de movimientos m√≠nimos
        """
        
        # Calcular diferencia desde el centro de la pantalla al objetivo
        diff_x = x - screen_x
        diff_y = y - screen_y
        
        # Calcular distancia euclidiana al objetivo
        distance = math.sqrt(diff_x**2 + diff_y**2)
        
        # SOLUCI√ìN 1: Zona muerta - si estamos MUY cerca, no mover
        # Esto evita el "jitter" (temblor) cuando ya estamos en el objetivo
        if distance < Aimbot.DEADZONE_RADIUS:
            if self.debug_counter % 60 == 0:
                print(colored(f"[DEBUG] MOVEMENT: Inside deadzone ({distance:.1f}px < {Aimbot.DEADZONE_RADIUS}px) - SKIP", "yellow"))
            return
        
        # SOLUCI√ìN 2: Suavizado adaptativo
        # Mientras m√°s cerca estamos, m√°s lento nos movemos
        smoothing = Aimbot.SMOOTHING_FACTOR
        
        if distance < Aimbot.APPROACH_THRESHOLD:
            # Aplicar suavizado extra cuando estamos cerca
            # A 10px: smoothing = 0.25 * (10/80) = 0.031 (MUY suave)
            # A 40px: smoothing = 0.25 * (40/80) = 0.125 (suave)
            # A 80px: smoothing = 0.25 * (80/80) = 0.25 (normal)
            smoothing *= (distance / Aimbot.APPROACH_THRESHOLD)
            if self.debug_counter % 30 == 0:
                print(colored(f"[DEBUG] MOVEMENT: Close approach mode. Distance={distance:.1f}px, Smoothing={smoothing:.3f}", "cyan"))

        # Determinar qu√© escala de sensibilidad usar (apuntando o desde la cadera)
        divisor = self.sens_config['targeting_scale'] if Aimbot.is_targeted() else self.sens_config['xy_scale']
        
        if divisor == 0:
            print(colored("[ERROR] MOVEMENT: Divisor is 0! Check config.json", "red"))
            return
        
        # Calcular movimiento base con sensibilidad y suavizado
        move_x = (diff_x / divisor) * smoothing
        move_y = (diff_y / divisor) * smoothing
        
        # SOLUCI√ìN 3: L√≠mite de velocidad m√°xima
        # Nunca mover m√°s de MAX_MOVE_PER_FRAME p√≠xeles en un solo frame
        move_magnitude = math.sqrt(move_x**2 + move_y**2)
        
        if move_magnitude > Aimbot.MAX_MOVE_PER_FRAME:
            # Escalar el movimiento para que no exceda el l√≠mite
            scale_factor = Aimbot.MAX_MOVE_PER_FRAME / move_magnitude
            move_x *= scale_factor
            move_y *= scale_factor
            if self.debug_counter % 30 == 0:
                print(colored(f"[DEBUG] MOVEMENT: Capped at max speed. Original={move_magnitude:.1f}px, Capped={Aimbot.MAX_MOVE_PER_FRAME}px", "yellow"))
        
        # SOLUCI√ìN 4: Filtro de movimientos insignificantes
        # Si el movimiento calculado es menor al umbral, ignorarlo
        if abs(move_x) < Aimbot.MIN_MOVE_THRESHOLD and abs(move_y) < Aimbot.MIN_MOVE_THRESHOLD:
            if self.debug_counter % 60 == 0:
                print(colored(f"[DEBUG] MOVEMENT: Movement too small ({move_x:.2f}, {move_y:.2f}) - SKIP", "yellow"))
            return
        
        # Ejecutar el movimiento
        if self.mouse_method.lower() == 'ddxoft':
            Aimbot.mouse_dll.DD_movR(int(move_x), int(move_y))
        elif self.mouse_method.lower() == 'win32':
            Aimbot.ii_.mi = MouseInput(int(move_x), int(move_y), 0, 0x0001, 0, ctypes.pointer(Aimbot.extra))
            command = Input(ctypes.c_ulong(0), Aimbot.ii_)
            ctypes.windll.user32.SendInput(1, ctypes.pointer(command), ctypes.sizeof(command))
        
        if self.debug_counter % 15 == 0:
            print(colored(f"[DEBUG] MOVEMENT: Dist={distance:.1f}px, Move=({int(move_x)},{int(move_y)}), Smooth={smoothing:.3f}", "green"))
        
        Aimbot.sleep(self.mouse_delay)


    def start(self):
        print("[INFO] Iniciando captura de pantalla")
        Aimbot.update_status_aimbot()
        half_screen_width = ctypes.windll.user32.GetSystemMetrics(0)/2
        half_screen_height = ctypes.windll.user32.GetSystemMetrics(1)/2
        detection_box = {'left': int(half_screen_width - self.box_constant//2), #x1 coord (for top-left corner of the box)
                          'top': int(half_screen_height - self.box_constant//2), #y1 coord (for top-left corner of the box)
                          'width': int(self.box_constant),  #width of the box
                          'height': int(self.box_constant)} #height of the box

        while self.running:
            start_time = time.perf_counter()
            frame = None
            try:
                with self.screen_lock:
                    if self.capture_method.lower() == 'bitblt':
                        frame = self.capture_screen_bitblt(detection_box)
                    elif self.capture_method.lower() == 'mss':
                        initial_frame = Aimbot.screen.grab(detection_box)
                        frame = np.array(initial_frame, dtype=np.uint8)
                    elif self.capture_method.lower() == 'auto':
                        frame = self.capture_screen_bitblt(detection_box)
                        if frame is None or frame.size == 0:
                            initial_frame = Aimbot.screen.grab(detection_box)
                            frame = np.array(initial_frame, dtype=np.uint8)
                
                if self.debug_counter % 30 == 0: # Print debug info every 30 frames
                    if frame is not None and frame.size > 0:
                        # Check if frame is mostly black, which indicates a capture issue
                        is_black = "Yes" if np.mean(frame) < 10 else "No"
                        print(colored(f"[DEBUG] CAPTURE: Method='{self.capture_method}', Shape={frame.shape}, All Black?={is_black}", "cyan"))
                    else:
                        print(colored(f"[DEBUG] CAPTURE: Frame capture FAILED via '{self.capture_method}'.", "red"))
                
                if frame is None or frame.size == 0:
                    self.failed_captures += 1
                    if self.failed_captures % 30 == 0:
                        print(f"[WARNING] La captura de pantalla devolvi√≥ un frame vac√≠o ({self.failed_captures} fallos)")
                        print("[INFO] Aseg√∫rate que el juego est√° en modo VENTANA SIN BORDES o prueba otro m√©todo de captura.")
                    continue
                else:
                    if self.failed_captures > 0:
                        self.failed_captures = 0
                
                frame = cv2.cvtColor(frame, cv2.COLOR_BGRA2BGR)
            except Exception as e:
                self.failed_captures += 1
                if self.failed_captures % 30 == 0:
                    print(f"[ERROR] La captura de pantalla fall√≥: {e}")
                    print(f"[INFO] Fallos de captura: {self.failed_captures}")
                time.sleep(0.1)
                continue
            
            try:
                use_half = (self.device == 'cuda' and self.cuda_compatible)
                boxes = self.model.predict(source=frame, verbose=False, conf=self.conf, iou=self.iou,
                                         half=use_half, device=self.device)
                result = boxes[0]
                
                if self.debug_counter % 30 == 0:
                    box_count = len(result.boxes)
                    color = "green" if box_count > 0 else "yellow"
                    print(colored(f"[DEBUG] PREDICT: Found {box_count} potential targets.", color))
            except Exception as e:
                print(f"[WARNING] La predicci√≥n de YOLO fall√≥: {e}")
                if self.device == 'cuda':
                    print("[INFO] La predicci√≥n con CUDA fall√≥, cambiando a CPU.")
                    try:
                        boxes = self.model.predict(source=frame, verbose=False, conf=self.conf, iou=self.iou,
                                                 half=False, device='cpu')
                        result = boxes[0]
                        self.device = 'cpu'
                        self.cuda_compatible = False
                        print(colored("[INFO] Se ha cambiado a modo CPU con √©xito.", "yellow"))
                    except Exception as e2:
                        print(f"[ERROR] La predicci√≥n con CPU tambi√©n fall√≥: {e2}")
                        continue
                else:
                    continue
            if len(result.boxes.xyxy) != 0: #player detected
                least_crosshair_dist = closest_detection = player_in_frame = False
                for box in result.boxes.xyxy: #iterate over each player detected
                    x1, y1, x2, y2 = map(int, box)
                    x1y1 = (x1, y1)
                    x2y2 = (x2, y2)
                    height = y2 - y1
                    relative_head_X, relative_head_Y = int((x1 + x2)/2), int((y1 + y2)/2 - height/aim_height) # offset to roughly approximate the head using a ratio of the height
                    own_player = x1 < 15 or (x1 < self.box_constant/5 and y2 > self.box_constant/1.2) # helps ensure that your own player is not regarded as a valid detection

                    crosshair_dist = math.dist((relative_head_X, relative_head_Y), (self.box_constant/2, self.box_constant/2))

                    if not least_crosshair_dist: least_crosshair_dist = crosshair_dist

                    if crosshair_dist <= least_crosshair_dist and not own_player:
                        least_crosshair_dist = crosshair_dist
                        closest_detection = {"x1y1": x1y1, "x2y2": x2y2, "relative_head_X": relative_head_X, "relative_head_Y": relative_head_Y}

                    if own_player:
                        own_player = False
                        if not player_in_frame:
                            player_in_frame = True

                if closest_detection: #if valid detection exists
                    cv2.circle(frame, (closest_detection["relative_head_X"], closest_detection["relative_head_Y"]), 5, (115, 244, 113), -1) #draw circle on the head
                    cv2.line(frame, (closest_detection["relative_head_X"], closest_detection["relative_head_Y"]), (self.box_constant//2, self.box_constant//2), (244, 242, 113), 2)

                    absolute_head_X, absolute_head_Y = closest_detection["relative_head_X"] + detection_box['left'], closest_detection["relative_head_Y"] + detection_box['top']
                    x1, y1 = closest_detection["x1y1"]

                    rel_x, rel_y = closest_detection['relative_head_X'], closest_detection['relative_head_Y']
                    dist = least_crosshair_dist
                    abs_coords_str = f"Abs Coords=({absolute_head_X},{absolute_head_Y})"
                    rel_coords_str = f"Rel Coords=({rel_x},{rel_y})"
                    print(colored(f"[DEBUG] TARGET: Closest found. Dist={dist:.1f}. {rel_coords_str}. {abs_coords_str}", "green"))

                    if Aimbot.is_target_locked(absolute_head_X, absolute_head_Y):
                        current_time = time.perf_counter()
                        
                        if use_trigger_bot and not Aimbot.is_shooting() and (current_time - self.last_shot_time) > self.shot_cooldown:
                            if self.consecutive_shots < self.max_consecutive_shots:
                                self.left_click()
                                self.last_shot_time = current_time
                                self.consecutive_shots += 1
                                
                                if human_like_delay:
                                    self.shot_cooldown = random.uniform(min_shot_delay, max_shot_delay)
                                else:
                                    self.shot_cooldown = 0.1
                            else:
                                self.consecutive_shots = 0
                                self.shot_cooldown = random.uniform(0.2, 0.4)

                        cv2.putText(frame, "LOCKED", (x1 + 40, y1), cv2.FONT_HERSHEY_DUPLEX, 0.5, (115, 244, 113), 2)
                    else:
                        cv2.putText(frame, "TARGETING", (x1 + 40, y1), cv2.FONT_HERSHEY_DUPLEX, 0.5, (115, 113, 244), 2)

                    if Aimbot.is_aimbot_enabled():
                        self.move_crosshair(absolute_head_X, absolute_head_Y)
                elif self.debug_counter % 30 == 0 and len(result.boxes) > 0:
                    # This case happens if detections are found but filtered out (e.g., as own player)
                    print(colored(f"[DEBUG] TARGET: Detections found, but none were valid targets after filtering.", "yellow"))

            fps = int(1/(time.perf_counter() - start_time)) if (time.perf_counter() - start_time) > 0 else 0
            cv2.putText(frame, f"FPS: {fps}", (5, 30), cv2.FONT_HERSHEY_DUPLEX, 1, (113, 116, 244), 2)
            
            try:
                cv2.imshow("Screen Capture", frame)
                if cv2.waitKey(1) & 0xFF == ord('0'):
                    break
            except Exception as e:
                print(f"[WARNING] Error de display OpenCV: {e}")
            
            # Increment debug counter at the end of each frame cycle
            self.debug_counter = (self.debug_counter + 1) % 6000

            elapsed_time = time.perf_counter() - start_time
            if elapsed_time < 0.016:
                time.sleep(0.016 - elapsed_time)

    def clean_up():
        print("\n[INFO] F2 PRESIONADO. CERRANDO...")
        try:
            if 'lunar' in globals():
                lunar.running = False
            Aimbot.screen.close()
            if Aimbot.mem_dc is not None:
                Aimbot.mem_dc.DeleteDC()
            if Aimbot.desktop_dc is not None:
                win32gui.ReleaseDC(win32gui.GetDesktopWindow(), Aimbot.desktop_dc)
            cv2.destroyAllWindows()
        except Exception as e:
            print(f"[WARNING] Error en la limpieza: {e}")
        finally:
            os._exit(0)

if __name__ == "__main__": print("Est√°s en el directorio incorrecto y ejecutando el archivo equivocado; debes ejecutar lunar.py")";

---------------------

EXACT PATH <C:\Users\olwer\Documents\GitHub\AI-Aimbot\lib\config\config.json>: "{
    "xy_sens": 5.0,
    "targeting_sens": 1.0,
    "xy_scale": 2.0,
    "targeting_scale": 200.0,
    "_comment_xy_scale": "Valores M√ÅS BAJOS = movimientos M√ÅS R√ÅPIDOS (recomendado: 2.0-10.0)",
    "_comment_targeting_scale": "Valores M√ÅS ALTOS = movimientos M√ÅS LENTOS/PRECISOS (recomendado: 150-300)"
}";

---------------------

EXACT PATH <C:\Users\olwer\Documents\GitHub\AI-Aimbot\lib\config\mouse_config.py>: """"
Aimbot Configuration
====================

This file allows you to easily configure mouse movement and screen capture methods
without editing the main aimbot.py file.

Usage:
    Just change the values below and restart the aimbot.
"""

# ============================================================================
# MOUSE MOVEMENT CONFIGURATION
# ============================================================================

# Available mouse methods:
# 'ddxoft' - Uses DDXoft driver (kernel-level, bypasses most anti-cheat) ‚¨ÖÔ∏è RECOMENDADO Y M√ÅS SEGURO
# 'win32'  - Uses Windows SendInput (DETECTABLE by anti-cheat, no funciona en pantalla completa)

MOUSE_METHOD = 'ddxoft'  # Usar 'ddxoft' por defecto. Si falla, el programa cambiar√° a 'win32' autom√°ticamente.

# Mouse movement settings
MOUSE_DELAY = 0.0009  # Delay between mouse movements (seconds)

# Sensitivity scaling (for fine-tuning mouse movement speed)
# Higher values = faster/more aggressive movement
# Lower values = slower/smoother movement
# Set to None to use values from config.json
TARGETING_SCALE_OVERRIDE = None  # Example: 50.0 for slower, 200.0 for faster

# ============================================================================
# ADVANCED MOVEMENT CONTROL (Soluci√≥n al overshooting)
# ============================================================================

# Zona muerta - radio en p√≠xeles donde NO se mueve el mouse
# Aumentar si hay "jitter" (temblor) cerca del objetivo
DEADZONE_RADIUS = 8  # Recomendado: 5-15

# Velocidad m√°xima por frame (l√≠mite de p√≠xeles por movimiento)
# Reducir si el mouse se mueve demasiado r√°pido y se pasa del objetivo
MAX_MOVE_PER_FRAME = 15  # Recomendado: 10-25

# Factor de suavizado (0.0 = no mover, 1.0 = sin suavizado)
# Reducir para movimientos m√°s suaves pero m√°s lentos
SMOOTHING_FACTOR = 0.25  # Recomendado: 0.15-0.35

# Distancia para activar suavizado extra (p√≠xeles)
# Cuando est√°s m√°s cerca que esto, el movimiento se vuelve M√ÅS suave
APPROACH_THRESHOLD = 80  # Recomendado: 60-100

# ============================================================================
# SCREEN CAPTURE CONFIGURATION
# ============================================================================

# Available capture methods:
# 'mss'    - R√°pido, pero NO FUNCIONA con juegos en pantalla completa (solo ventana sin bordes)
# 'bitblt' - M√°s lento, pero FUNCIONA CON JUEGOS EN PANTALLA COMPLETA
# 'auto'   - Intenta 'bitblt' primero, y si falla, usa 'mss'.

CAPTURE_METHOD = 'bitblt'  # ‚¨ÖÔ∏è RECOMENDADO para juegos en pantalla completa

# ============================================================================
# DEBUG SETTINGS
# ============================================================================

DEBUG_MOUSE_MOVEMENT = True  # Show debug messages for mouse movement
DEBUG_SCREEN_CAPTURE = True  # Show debug messages for screen capture
DEBUG_FREQUENCY = 30  # Show debug message every N frames (lower = more messages)

# ============================================================================
# ADVANCED SETTINGS (Don't change unless you know what you're doing)
# ============================================================================

# SendInput flags (only for 'win32' method)
# 0x0001 = MOUSEEVENTF_MOVE (relative movement)
# 0x8000 = MOUSEEVENTF_MOVE_NOCOALESCE (don't merge movements)
SENDINPUT_FLAGS = 0x0001";