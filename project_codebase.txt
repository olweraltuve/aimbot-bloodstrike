EXACT PATH <C:\Users\olwer\Documents\GitHub\AI-Aimbot\admin_check.py>: """"
Admin Permission Check and Elevation for Windows
This module provides functions to check for administrator privileges
and request elevation if needed for the AI Aimbot application.
"""

import ctypes
import os
import sys
import subprocess
import platform
from termcolor import colored

def is_admin():
    """
    Check if the current process has administrator privileges.
    
    Returns:
        bool: True if running as administrator, False otherwise
    """
    try:
        # Method 1: Check using ctypes (Windows)
        if platform.system() == 'Windows':
            return ctypes.windll.shell32.IsUserAnAdmin()
        else:
            # On non-Windows systems, check for root/sudo
            return os.geteuid() == 0
    except Exception as e:
        print(f"[WARNING] Failed to check admin status: {e}")
        return False

def request_admin_elevation():
    """
    Request administrator privileges by restarting the script with UAC prompt.
    
    Returns:
        bool: True if elevation was requested, False if already admin or failed
    """
    if is_admin():
        return False  # Already running as admin
    
    print(colored("[INFO] Administrator privileges required for optimal performance", "yellow"))
    print(colored("[INFO] Requesting elevation via UAC...", "yellow"))
    
    try:
        # Get the current script path
        script = os.path.abspath(sys.argv[0])
        params = ' '.join([f'"{arg}"' for arg in sys.argv[1:]])
        
        # Request UAC elevation
        ctypes.windll.shell32.ShellExecuteW(
            None,  # hwnd
            "runas",  # operation (run as administrator)
            sys.executable,  # executable (Python interpreter)
            f'"{script}" {params}',  # parameters
            None,  # working directory
            1  # nShow (SW_SHOWNORMAL)
        )
        
        print(colored("[SUCCESS] Admin elevation requested. Please accept UAC prompt.", "green"))
        return True
        
    except Exception as e:
        print(colored(f"[ERROR] Failed to request admin elevation: {e}", "red"))
        print(colored("[INFO] You can run the application as administrator manually", "yellow"))
        return False

def check_and_request_admin():
    """
    Main function to check admin status and request elevation if needed.
    
    Returns:
        bool: True if running as admin or elevation successful, False otherwise
    """
    if is_admin():
        print(colored("[SUCCESS] Running with administrator privileges", "green"))
        return True
    
    print(colored("[WARNING] Running without administrator privileges", "yellow"))
    print(colored("[INFO] Some features may not work optimally:", "yellow"))
    print(colored("  - Low-level mouse input simulation", "yellow"))
    print(colored("  - Screen capture in fullscreen applications", "yellow"))
    print(colored("  - System-level optimizations", "yellow"))
    
    # Ask user if they want to elevate
    try:
        response = input(colored("Do you want to restart with admin privileges? (y/N): ", "cyan")).strip().lower()
        if response in ['y', 'yes']:
            if request_admin_elevation():
                sys.exit(0)  # Exit current process, elevated one will start
            else:
                print(colored("[INFO] Continuing without admin privileges...", "yellow"))
                return False
        else:
            print(colored("[INFO] Continuing without admin privileges...", "yellow"))
            return False
    except (KeyboardInterrupt, EOFError):
        print(colored("\n[INFO] Continuing without admin privileges...", "yellow"))
        return False

def get_admin_benefits():
    """
    Returns a description of benefits when running with admin privileges.
    """
    benefits = [
        "Enhanced mouse input simulation for better anti-cheat compatibility",
        "Improved screen capture in fullscreen applications",
        "Better system resource management",
        "Reduced input latency",
        "Compatibility with more game protection systems"
    ]
    return benefits

if __name__ == "__main__":
    # Test the admin check functionality
    print("Admin Permission Check Test")
    print(f"Running as admin: {is_admin()}")
    
    if not is_admin():
        print("Benefits of admin privileges:")
        for benefit in get_admin_benefits():
            print(f"  - {benefit}")
        
        if input("Test elevation? (y/N): ").lower() == 'y':
            check_and_request_admin()";

---------------------

EXACT PATH <C:\Users\olwer\Documents\GitHub\AI-Aimbot\install_python312.bat>: "@echo off
echo ===============================================
echo Python 3.12 Installation Script
echo ===============================================
echo.
echo This will install Python 3.12 alongside your existing Python 3.13
echo without overwriting or affecting your current installation.
echo.

echo Downloading Python 3.12 installer...
powershell -Command "Invoke-WebRequest -Uri 'https://www.python.org/ftp/python/3.12.0/python-3.12.0-amd64.exe' -OutFile 'python312-installer.exe'"

if exist python312-installer.exe (
    echo.
    echo Running Python 3.12 installer...
    echo IMPORTANT: During installation, make sure to:
    echo   - Check "Add python.exe to PATH"
    echo   - Click "Customize installation"
    echo   - In Advanced Options, check "Install for all users"
    echo   - Change installation path to: C:\Python312\
    echo   - DO NOT check "Associate files with Python"
    echo.
    echo The installer will now open. Please follow the instructions above.
    echo.
    pause
    start /wait python312-installer.exe
) else (
    echo Failed to download Python 3.12 installer
    echo Please download manually from:
    echo https://www.python.org/downloads/release/python-3120/
    pause
    exit /b 1
)

echo.
echo Cleaning up installer...
del python312-installer.exe

echo.
echo Verifying Python 3.12 installation...
where python3.12 >nul 2>&1
if %errorlevel% equ 0 (
    echo Python 3.12 successfully installed!
    echo.
    echo Now run setup_cuda.bat to set up the CUDA environment.
) else (
    echo Python 3.12 installation may have failed.
    echo Please check if Python 3.12 is available in your system.
)

echo.
pause";

---------------------

EXACT PATH <C:\Users\olwer\Documents\GitHub\AI-Aimbot\install_python313.bat>: "@echo off
echo ===============================================
echo Python 3.13 Installation Script
echo ===============================================
echo.
echo This will install Python 3.13 for Windows.
echo.

echo Downloading Python 3.13 installer...
powershell -Command "Invoke-WebRequest -Uri 'https://www.python.org/ftp/python/3.13.0/python-3.13.0-amd64.exe' -OutFile 'python313-installer.exe'"

if exist python313-installer.exe (
    echo.
    echo Running Python 3.13 installer...
    echo IMPORTANT: During installation, make sure to:
    echo   - Check "Add python.exe to PATH"
    echo   - Click "Customize installation"
    echo   - In Advanced Options, check "Install for all users"
    echo   - Change installation path to: C:\Python313\
    echo   - DO NOT check "Associate files with Python"
    echo.
    echo The installer will now open. Please follow the instructions above.
    echo.
    pause
    start /wait python313-installer.exe
) else (
    echo Failed to download Python 3.13 installer
    echo Please download manually from:
    echo https://www.python.org/downloads/release/python-3130/
    pause
    exit /b 1
)

echo.
echo Cleaning up installer...
del python313-installer.exe

echo.
echo Verifying Python 3.13 installation...
where python >nul 2>&1
if %errorlevel% equ 0 (
    echo Python 3.13 successfully installed!
    echo.
    echo Now run setup_cuda.bat to set up the CUDA environment.
) else (
    echo Python 3.13 installation may have failed.
    echo Please check if Python 3.13 is available in your system.
)

echo.
pause";

---------------------

EXACT PATH <C:\Users\olwer\Documents\GitHub\AI-Aimbot\install_requirements.bat>: "pip install -r requirements.txt --no-cache-dir
pause
";

---------------------

EXACT PATH <C:\Users\olwer\Documents\GitHub\AI-Aimbot\lunar.py>: "import json
import os
import sys
from pynput import keyboard
from termcolor import colored

# Import admin check module
try:
    from admin_check import check_and_request_admin
except ImportError:
    print("[WARNING] Admin check module not found. Running without admin privileges check.")
    def check_and_request_admin():
        return False

def on_release(key):
    try:
        if key == keyboard.Key.f1:
            Aimbot.update_status_aimbot()
        if key == keyboard.Key.f2:
            Aimbot.clean_up()
    except NameError:
        pass

def main():
    global lunar
    lunar = Aimbot(collect_data = "collect_data" in sys.argv)
    lunar.start()

def setup():
    path = "lib/config"
    if not os.path.exists(path):
        os.makedirs(path)

    print("[INFO] In-game X and Y axis sensitivity should be the same")
    def prompt(str):
        valid_input = False
        while not valid_input:
            try:
                number = float(input(str))
                valid_input = True
            except ValueError:
                print("[!] Invalid Input. Make sure to enter only the number (e.g. 6.9)")
        return number

    xy_sens = prompt("X-Axis and Y-Axis Sensitivity (from in-game settings): ")
    targeting_sens = prompt("Targeting Sensitivity (from in-game settings): ")

    print("[INFO] Your in-game targeting sensitivity must be the same as your scoping sensitivity")
    sensitivity_settings = {"xy_sens": xy_sens, "targeting_sens": targeting_sens, "xy_scale": 10/xy_sens, "targeting_scale": 1000/(targeting_sens * xy_sens)}

    with open('lib/config/config.json', 'w') as outfile:
        json.dump(sensitivity_settings, outfile)
    print("[INFO] Sensitivity configuration complete")

if __name__ == "__main__":
    os.system('cls' if os.name == 'nt' else 'clear')
    os.environ['PYGAME_HIDE_SUPPORT_PROMPT'] = '1'
    
    # Check and request admin privileges if needed
    check_and_request_admin()

    print(colored(r'''

  _    _   _ _   _    _    ____     _     ___ _____ _____
 | |  | | | | \ | |  / \  |  _ \   | |   |_ _|_   _| ____|
 | |  | | | |  \| | / _ \ | |_) |  | |    | |  | | |  _|
 | |__| |_| | |\  |/ ___ \|  _ <   | |___ | |  | | | |___
 |_____\___/|_| \_/_/   \_\_| \_\  |_____|___| |_| |_____|
                                                                          
(Neural Network Aimbot)''', "green"))
    
    print(colored('To get full version of Lunar V2, visit https://gannonr.com/lunar OR join the discord: discord.gg/aiaimbot', "red"))

    path_exists = os.path.exists("lib/config/config.json")
    if not path_exists or ("setup" in sys.argv):
        if not path_exists:
            print("[!] Sensitivity configuration is not set")
        setup()
    path_exists = os.path.exists("lib/data")
    if "collect_data" in sys.argv and not path_exists:
        os.makedirs("lib/data")
    from lib.aimbot import Aimbot
    listener = keyboard.Listener(on_release=on_release)
    listener.start()
    main()
";

---------------------

EXACT PATH <C:\Users\olwer\Documents\GitHub\AI-Aimbot\README.md>: "# 🧠 YoloV12 AI Aimbot - Lunar LITE

**Lunar LITE** is built on top of the original [Lunar](https://github.com/zeyad-mansour/lunar) project.

It features an updated triggerbot, modernized packages, and YOLOv12 support.

<div align="center">

<img src="https://ucarecdn.com/97ff66ce-04db-424f-97ad-3f246ebabef6/lunar_downloads.svg" alt="downloads" /><br>
<a href="https://discord.gg/aiaimbot">
  <img src="https://ucarecdn.com/c6b01f6a-a399-46e7-b89b-3f39b198888e/lunar_discord.svg" alt="Join Discord" />
</a>

</div>

---

## 🚀 Lunar V2 (Premium)

**Lunar V2** includes:

- ✅ 25+ customizable settings  
- ✅ Built-in UI  
- ✅ Improved detection accuracy  
- ✅ Supports **YOLOv8**, **YOLOv10**, **YOLOv12**, and **TensorRT**  
- ✅ Xbox controller support
- ✅ Logitech GHUB mouse input
- ✅ Works on AMD and NVIDIA graphics cards

[Download Lunar V2](https://gannonr.com/lunar)

![Lunar V2 UI](https://github.com/user-attachments/assets/173ace44-2a46-45a3-aeba-5c2ce9c9e7b4)

---

## ❓ What Is an AI Aimbot?

Lunar uses screen capture + YOLO object detection to locate enemies in real-time.

> It doesn’t touch memory or inject code — think of it as a robot that watches your screen and gives you precise X,Y coordinates of targets.

🎯 Preconfigured for **Fortnite** — some sensitivity tuning may be needed for other games.

---

## 🔧 YOLOv12 Support

Lunar LITE works with:
- [YOLOv8](https://github.com/ultralytics/ultralytics)
- [YOLOv10](https://github.com/ultralytics/ultralytics)
- [YOLOv12](https://github.com/ultralytics/ultralytics)

---

![Lunar Lite Banner](https://github.com/user-attachments/assets/05864acf-cdd1-484f-be79-fa4a9643e8c2)
![Thumbnail](https://github.com/user-attachments/assets/afa30dd2-8168-4c64-999e-bedb0bef4dec)

---

<details>
<summary>📦 <strong>Installation</strong></summary>

1. Install [Python 3.10.5](https://www.python.org/downloads/release/python-3105/)
2. Install **CUDA Toolkit** 11.8, 12.4, or 12.6 (**12.6 recommended**)
3. Navigate to the root folder and run:
    ```
    install_requirements.bat
    ```
4. Launch with:
    ```
    start.bat
    ```

</details>

---

<details>
<summary>⚙️ <strong>Usage / Troubleshooting</strong></summary>

### If you get `CUDA IS UNAVAILABLE` error:
1. Make sure your installed CUDA version matches.
2. Visit [pytorch.org](https://pytorch.org/get-started/locally/) and install the right build.

Command for CUDA 12.6:
```
pip3 install torch torchvision torchaudio --index-url https://download.pytorch.org/whl/cu126
```

---

### If the aimbot only works when you Alt+Tab (doesn't work in-game):

**⚠️ This is the MOST COMMON issue - the problem is screen capture, not mouse movement.**

**🔧 Solution (Already Implemented):**

The code now uses **BitBlt** by default, which works with fullscreen games. Just verify:
- Open `lib/config/mouse_config.py`
- Confirm: `CAPTURE_METHOD = 'bitblt'`

**Alternative Solutions:**
1. **Change game to BORDERLESS WINDOWED mode** (most reliable)
   - Go to game settings → Display/Video
   - Change from "Fullscreen" to "Borderless Windowed"

2. **Use auto-detection mode:**
   - In `lib/config/mouse_config.py`
   - Change: `CAPTURE_METHOD = 'auto'`

---

### If the aimbot detects targets but doesn't move the mouse:

**The code now uses DDXoft by default (kernel-level, less detectable).**

**If DDXoft driver doesn't work on your system:**

1. **Verify DDXoft is available:**
   - Check that `lib/mouse/dd40605x64.dll` exists
   - If missing, download from the original Lunar repository

2. **Fallback to Win32 if needed:**
   - Open `lib/config/mouse_config.py`
   - Change: `MOUSE_METHOD = 'win32'`
   - **WARNING:** Win32 is more detectable by anti-cheat

3. **Adjust sensitivity if needed:**
   - Edit `lib/config/config.json`
   - Lower `targeting_scale` for smoother movement
   - Higher values = faster/more aggressive

📖 See `SOLUCION_MOUSE_MOVEMENT.md` for detailed troubleshooting guide.

---

### If the console closes instantly:
```
python lunar.py
```

---

### To configure sensitivity:
```
python lunar.py setup
```

---

### To collect training images:
```
python lunar.py collect_data
```

</details>

---

## 💬 Discord Support

Support is only **guaranteed** for **Lunar V2**.  
Please don’t expect full help for the free **LITE** version.

👉 [Join our Discord](https://discord.gg/aiaimbot)
";

---------------------

EXACT PATH <C:\Users\olwer\Documents\GitHub\AI-Aimbot\reinstall_stable_pytorch.bat>: "@echo off
echo ===============================================
echo AI Aimbot - Reinstall Stable PyTorch
echo ===============================================
echo.

echo This script will reinstall the stable PyTorch version
echo and ensure the aimbot works reliably in CPU mode.
echo.

echo Removing current PyTorch installation...
call venv_cuda\Scripts\activate
pip uninstall torch torchvision torchaudio -y

echo.
echo Installing stable PyTorch with CUDA 12.4 support...
pip install torch torchvision torchaudio --index-url https://download.pytorch.org/whl/cu124

echo.
echo Installing other dependencies...
pip install -r requirements_cuda.txt

echo.
echo Verifying installation...
venv_cuda\Scripts\python -c "import torch; print('PyTorch version:', torch.__version__); print('CUDA available:', torch.cuda.is_available()); print('GPU name:', torch.cuda.get_device_name(0) if torch.cuda.is_available() else 'N/A'); print('Compute capability:', torch.cuda.get_device_capability(0) if torch.cuda.is_available() else 'N/A')"

echo.
echo ===============================================
echo IMPORTANT INFORMATION FOR RTX 5060 USERS
echo ===============================================
echo.
echo Your RTX 5060 GPU (sm_120) is not yet supported by stable PyTorch.
echo.
echo The aimbot will run in CPU mode which is slower but functional.
echo.
echo For future CUDA support:
echo - PyTorch nightly builds may eventually support RTX 5060
echo - Check https://pytorch.org/get-started/locally/ for updates
echo - The aimbot will automatically detect when CUDA becomes available
echo.
echo ===============================================
echo Reinstallation Complete!
echo ===============================================
echo.
echo Run: python lunar.py
echo The aimbot will automatically use CPU mode for now.
pause";

---------------------

EXACT PATH <C:\Users\olwer\Documents\GitHub\AI-Aimbot\requirements.txt>: "# CPU-only PyTorch installation (default for Python 3.13+)
# For CUDA acceleration, use requirements_cuda.txt with Python 3.12
--find-links https://download.pytorch.org/whl/torch_stable.html

torch>=2.6.0
torchvision>=0.17.0
ultralytics>=8.0.0

matplotlib>=3.2.2
numpy>=1.26.4
opencv-python>=4.1.2
Pillow
PyYAML>=5.3.1
scipy>=1.4.1
tqdm>=4.41.0
tensorboard>=2.4.1
seaborn>=0.11.0
pandas

mss
pygame
pynput
pywin32
requests
wheel
termcolor
";

---------------------

EXACT PATH <C:\Users\olwer\Documents\GitHub\AI-Aimbot\requirements_cuda.txt>: "# CUDA-enabled PyTorch installation for RTX 5060 (sm_120) compatibility
# Use with Python 3.13 for CUDA acceleration
--find-links https://download.pytorch.org/whl/nightly/cu124

# PyTorch with CUDA 12.4 support for RTX 5060 (sm_120)
# Using nightly build for RTX 5060 (sm_120) compatibility
torch>=2.6.0
torchvision>=0.21.0
torchaudio>=2.6.0

# Core dependencies
ultralytics>=8.0.0
matplotlib>=3.2.2
numpy>=1.26.4
opencv-python>=4.1.2
Pillow
PyYAML>=5.3.1
scipy>=1.4.1
tqdm>=4.41.0
tensorboard>=2.4.1
seaborn>=0.11.0
pandas

# Game integration
mss
pygame
pynput
pywin32
requests
wheel
termcolor";

---------------------

EXACT PATH <C:\Users\olwer\Documents\GitHub\AI-Aimbot\setup_cuda.bat>: "@echo off
echo ===============================================
echo AI Aimbot CUDA Setup Script
echo ===============================================
echo.

echo Checking for existing Python 3.13 installation...
where python >nul 2>&1
if %errorlevel% equ 0 (
    echo Python found!
    goto :create_venv
) else (
    echo Python not found.
    echo.
    echo Python 3.13 is required but not found in system PATH.
    echo.
    echo Options:
    echo 1. Run install_python313.bat to install Python 3.13 automatically
    echo 2. Install Python 3.13 manually from python.org
    echo 3. Ensure Python is added to PATH during installation
    echo.
    echo After installing Python 3.13, run this script again.
    pause
    exit /b 1
)

:create_venv
echo.
echo Creating CUDA-enabled virtual environment...
python -m venv venv_cuda
if %errorlevel% neq 0 (
    echo Failed to create virtual environment
    pause
    exit /b 1
)

echo.
echo Activating virtual environment...
call venv_cuda\Scripts\activate

echo.
echo Installing CUDA-enabled PyTorch and dependencies for RTX 5060 (sm_120)...
echo Using PyTorch nightly build for RTX 5060 (sm_120) compatibility...
pip install --pre torch torchvision torchaudio --index-url https://download.pytorch.org/whl/nightly/cu124
if %errorlevel% neq 0 (
    echo Failed to install PyTorch with CUDA
    pause
    exit /b 1
)

echo.
echo Installing other requirements...
pip install -r requirements_cuda.txt
if %errorlevel% neq 0 (
    echo Failed to install requirements
    pause
    exit /b 1
)

echo.
echo Verifying CUDA installation and RTX 5060 compatibility...
python -c "import torch; print('PyTorch version:', torch.__version__); print('CUDA available:', torch.cuda.is_available()); print('CUDA version:', torch.version.cuda if torch.cuda.is_available() else 'N/A'); print('GPU count:', torch.cuda.device_count()); print('GPU name:', torch.cuda.get_device_name(0) if torch.cuda.device_count() > 0 else 'N/A'); print('Compute capability:', torch.cuda.get_device_capability(0) if torch.cuda.device_count() > 0 else 'N/A'); print('RTX 5060 (sm_120) support:', 'YES' if torch.cuda.is_available() and torch.cuda.get_device_capability(0) >= (12, 0) else 'NO')"

echo.
echo ===============================================
echo CUDA Setup Complete!
echo ===============================================
echo.
echo To use the CUDA-enabled environment:
echo   venv_cuda\Scripts\activate
echo   python lunar.py
echo.
echo Your aimbot should now run with CUDA acceleration!
pause";

---------------------

EXACT PATH <C:\Users\olwer\Documents\GitHub\AI-Aimbot\start.bat>: "@echo off
echo ===============================================
echo Lunar AI Aimbot - CUDA Enabled
echo ===============================================
echo.

echo Checking for CUDA virtual environment...
if not exist "venv_cuda\Scripts\activate.bat" (
    echo CUDA virtual environment not found!
    echo Please run setup_cuda.bat first to set up the CUDA environment.
    echo.
    pause
    exit /b 1
)

echo Activating CUDA virtual environment...
call venv_cuda\Scripts\activate.bat

echo Running Lunar AI Aimbot with CUDA acceleration...
python lunar.py
pause
";

---------------------

EXACT PATH <C:\Users\olwer\Documents\GitHub\AI-Aimbot\start_admin.bat>: "@echo off
setlocal enabledelayedexpansion

:: Check if running as administrator
net session >nul 2>&1
if %errorLevel% == 0 (
    echo Running with administrator privileges
) else (
    echo Requesting administrator privileges automatically...
    echo.
    echo If you reject the UAC prompt, the application will not run.
    echo.
    :: Re-launch as admin automatically (no y/n prompt)
    PowerShell -Command "$process = Start-Process cmd -ArgumentList '/c %~dpnx0' -Verb RunAs -PassThru; if (!$process) { Write-Error 'Administrator privileges required' }"
    if %errorLevel% neq 0 (
        echo.
        echo ERROR: Administrator privileges are required to run this application.
        echo Please accept the UAC prompt to continue.
        echo.
        pause
        exit /b 1
    )
    exit /b
)

echo ===============================================
echo Lunar AI Aimbot - Administrator Mode with CUDA
echo ===============================================
echo.

:: Check for Python installation
echo Checking for Python 3.13 installation...
where python >nul 2>&1
if %errorlevel% neq 0 (
    echo Python 3.13 not found in system PATH.
    echo.
    echo Installing Python 3.13 for Windows...
    echo.
    call install_python313.bat
    if %errorlevel% neq 0 (
        echo Python installation failed. Please install Python 3.13 manually.
        pause
        exit /b 1
    )
) else (
    echo Python found in system.
)

echo Checking for CUDA virtual environment...
if not exist "venv_cuda\Scripts\activate.bat" (
    echo CUDA virtual environment not found!
    echo Please run setup_cuda.bat first to set up the CUDA environment.
    echo.
    pause
    exit /b 1
)

echo Activating CUDA virtual environment...
call venv_cuda\Scripts\activate.bat

echo Running Lunar AI Aimbot with administrator privileges and CUDA acceleration...
echo.
echo Benefits of running as administrator:
echo - Enhanced mouse input simulation
echo - Improved screen capture in fullscreen applications
echo - Better system resource management
echo - Reduced input latency
echo - Compatibility with more game protection systems
echo - CUDA acceleration for AI processing
echo.
python lunar.py
pause";

---------------------

EXACT PATH <C:\Users\olwer\Documents\GitHub\AI-Aimbot\test_mouse_movement.py>: """"
Test Mouse Movement Script
===========================

This script tests if SendInput mouse movement works on your system.
Run this BEFORE testing in-game to verify that the mouse movement method works.

Instructions:
1. Run this script: python test_mouse_movement.py
2. Watch your mouse cursor - it should move in a small circle
3. If the mouse moves, SendInput works on your system
4. If the mouse doesn't move, you need to use ddxoft method instead
"""

import ctypes
import time
import math

PUL = ctypes.POINTER(ctypes.c_ulong)

class MouseInput(ctypes.Structure):
    _fields_ = [("dx", ctypes.c_long),
                ("dy", ctypes.c_long),
                ("mouseData", ctypes.c_ulong),
                ("dwFlags", ctypes.c_ulong),
                ("time", ctypes.c_ulong),
                ("dwExtraInfo", PUL)]

class Input_I(ctypes.Union):
    _fields_ = [("mi", MouseInput)]

class Input(ctypes.Structure):
    _fields_ = [("type", ctypes.c_ulong),
                ("ii", Input_I)]

def test_sendinput():
    print("=" * 60)
    print("Testing SendInput Mouse Movement")
    print("=" * 60)
    print("\nYour mouse should move in a small circle...")
    print("If it doesn't move, SendInput is blocked on your system.\n")
    
    extra = ctypes.c_ulong(0)
    ii_ = Input_I()
    
    # Wait 3 seconds before starting
    for i in range(3, 0, -1):
        print(f"Starting in {i}...")
        time.sleep(1)
    
    print("\n[TEST] Moving mouse in circle pattern...")
    
    # Draw a circle with mouse movement
    radius = 50
    steps = 36  # 36 steps = 10 degrees each
    success_count = 0
    
    for i in range(steps):
        angle = (i / steps) * 2 * math.pi
        
        # Calculate movement for this step
        if i == 0:
            dx = int(radius * math.cos(angle))
            dy = int(radius * math.sin(angle))
        else:
            prev_angle = ((i-1) / steps) * 2 * math.pi
            prev_x = int(radius * math.cos(prev_angle))
            prev_y = int(radius * math.sin(prev_angle))
            curr_x = int(radius * math.cos(angle))
            curr_y = int(radius * math.sin(angle))
            dx = curr_x - prev_x
            dy = curr_y - prev_y
        
        # Use SendInput to move mouse
        ii_.mi = MouseInput(dx, dy, 0, 0x0001, 0, ctypes.pointer(extra))
        command = Input(ctypes.c_ulong(0), ii_)
        result = ctypes.windll.user32.SendInput(1, ctypes.pointer(command), ctypes.sizeof(command))
        
        if result == 1:
            success_count += 1
        
        print(f"Step {i+1}/{steps}: dx={dx:4d}, dy={dy:4d}, result={result}")
        time.sleep(0.05)  # 50ms delay between movements
    
    print("\n" + "=" * 60)
    print(f"Test Complete: {success_count}/{steps} movements successful")
    print("=" * 60)
    
    if success_count == steps:
        print("\n✅ SUCCESS! SendInput works perfectly on your system.")
        print("   You can use 'win32' method in mouse_config.py")
    elif success_count > 0:
        print("\n⚠️  PARTIAL SUCCESS! SendInput works but may be unreliable.")
        print("   Consider using 'ddxoft' method in mouse_config.py")
    else:
        print("\n❌ FAILED! SendInput is blocked on your system.")
        print("   You MUST use 'ddxoft' method in mouse_config.py")
        print("\n   To enable ddxoft:")
        print("   1. Open lib/config/mouse_config.py")
        print("   2. Change: MOUSE_METHOD = 'ddxoft'")
        print("   3. Restart the aimbot")
    
    print("\n")

if __name__ == "__main__":
    try:
        test_sendinput()
    except Exception as e:
        print(f"\n❌ ERROR: {e}")
        print("\nThe test failed with an error.")
        print("You may need to run this script as Administrator.")
    
    input("\nPress ENTER to exit...")

";

---------------------

EXACT PATH <C:\Users\olwer\Documents\GitHub\AI-Aimbot\update_cuda_for_rtx5060.bat>: "@echo off
echo ===============================================
echo AI Aimbot RTX 5060 CUDA Compatibility Update
echo ===============================================
echo.

echo This script will update your CUDA installation to support RTX 5060 (sm_120)
echo.

echo Checking current PyTorch installation...
venv_cuda\Scripts\python -c "import torch; print('Current PyTorch version:', torch.__version__); print('CUDA available:', torch.cuda.is_available()); print('Compute capability:', torch.cuda.get_device_capability(0) if torch.cuda.is_available() else 'N/A')"

echo.
echo Updating PyTorch to nightly build for RTX 5060 compatibility...
call venv_cuda\Scripts\activate
pip uninstall torch torchvision torchaudio -y
pip install --pre torch torchvision --index-url https://download.pytorch.org/whl/nightly/cu124

echo.
echo Verifying RTX 5060 compatibility...
venv_cuda\Scripts\python -c "import torch; print('=== CUDA Compatibility Check ==='); print('PyTorch version:', torch.__version__); print('CUDA available:', torch.cuda.is_available()); print('CUDA version:', torch.version.cuda if torch.cuda.is_available() else 'N/A'); print('GPU count:', torch.cuda.device_count()); print('GPU name:', torch.cuda.get_device_name(0) if torch.cuda.device_count() > 0 else 'N/A'); print('Compute capability:', torch.cuda.get_device_capability(0) if torch.cuda.device_count() > 0 else 'N/A'); print('RTX 5060 (sm_120) support:', 'YES' if torch.cuda.is_available() and torch.cuda.get_device_capability(0) >= (12, 0) else 'NO')"

echo.
echo ===============================================
echo Update Complete!
echo ===============================================
echo.
echo If CUDA functionality test passed, your RTX 5060 should now work with the aimbot.
echo If it failed, the aimbot will automatically fall back to CPU mode.
echo.
echo Run: python lunar.py
pause";

---------------------

EXACT PATH <C:\Users\olwer\Documents\GitHub\AI-Aimbot\docs\doc1.txt>: "Entiendo perfectamente tu objetivo. Quieres probar la robustez de tu propio sistema anti-cheat, y para ello necesitas simular las acciones que un cheat real intentaría realizar, incluyendo el intento de pasar desapercibido. Este es un enfoque de "pentesting" o pruebas de seguridad muy válido y una excelente práctica en el desarrollo de juegos.

Tienes toda la razón, las librerías comunes como `win32api`, `pyautogui`, o `SendInput` son de las primeras cosas que un sistema anti-cheat aprende a detectar. Vamos a abordar tu pregunta desde una perspectiva defensiva y educativa, explicando *por qué* son detectables y qué conceptos utilizan las técnicas más avanzadas para ocultarse, para que así puedas fortalecer tu sistema.

### ¿Por qué `win32api` y librerías similares son detectables?

Los sistemas anti-cheat detectan estas librerías por varias razones:

1.  **Flags de inyección:** Funciones como `SendInput` marcan los eventos de entrada con un flag (como `LLMHF_INJECTED`) que indica que el evento no proviene de un dispositivo de hardware real. Un anti-cheat a nivel de sistema (kernel) puede interceptar estos eventos y ver el flag fácilmente.
2.  **Movimientos inhumanos:** Los scripts básicos generan movimientos predecibles y perfectos:
    *   **Líneas rectas:** El cursor se mueve en una línea perfectamente recta desde el punto A al punto B. Ningún humano hace eso.
    *   **Velocidad constante:** El movimiento es instantáneo o a una velocidad uniforme, sin aceleración ni desaceleración.
    *   **Precisión perfecta:** Siempre acierta en el mismo píxel exacto.
3.  **Hooks de API:** Los anti-cheats pueden "hookear" (interceptar) las llamadas a funciones conocidas del sistema operativo. Si detectan que tu juego está recibiendo eventos de mouse que no pasaron por la cadena normal de hardware, pero sí por una llamada a `SendInput`, es una bandera roja inmediata.

### Conceptos de simulación de movimientos ocultos (para que sepas qué buscar)

En lugar de darte una librería "indetectable" (lo cual sería irresponsable, ya que no existe tal cosa y sería información de doble uso), te explicaré los **métodos y conceptos** que los desarrolladores de cheats intentan usar. Conociéndolos, podrás mejorar tu anti-cheat para detectarlos.

#### 1. Simulación a nivel de Kernel (Drivers)

Esta es la técnica más común en cheats avanzados. En lugar de usar una API de alto nivel en modo usuario (como `win32api`), se crea un **driver en modo kernel**.

*   **¿Cómo funciona?** El driver se comunica directamente con la pila de entrada del sistema operativo, creando paquetes de entrada (input packets) que son prácticamente indistinguibles de los que genera un driver de mouse real. De esta forma, se saltan los hooks en modo usuario y los flags de inyección.
*   **¿Cómo detectarlo?**
    *   **Detección de drivers no firmados o sospechosos:** Los anti-cheats con acceso a nivel de kernel (como Easy Anti-Cheat, BattlEye) escanean la lista de drivers cargados en el sistema en busca de firmas desconocidas o en listas negras.
    *   **Análisis de comportamiento:** Aunque el evento parezca legítimo, el *patrón* de movimiento puede seguir siendo inhumano si el programador del cheat no se esforzó en "humanizarlo". Tu anti-cheat debe analizar la telemetría del mouse (velocidad, aceleración, desviación) para detectar patrones artificiales.

#### 2. Simulación a nivel de Hardware

Esta es la técnica más difícil de detectar desde el software.

*   **¿Cómo funciona?** Se utiliza un dispositivo externo, como una placa Arduino o un Raspberry Pi, programado para actuar como un dispositivo de entrada USB (un "USB HID"). Para el sistema operativo, este dispositivo es un mouse o un teclado real. Los comandos se le envían desde el PC (por ejemplo, a través de un puerto serie) y el dispositivo externo genera los movimientos de mouse correspondientes.
*   **¿Cómo detectarlo?**
    *   **Es extremadamente difícil.** La detección se basa casi exclusivamente en el análisis de comportamiento. No hay un driver malicioso ni una API hookeable.
    *   **Análisis estadístico:** La única defensa real es un análisis estadístico muy robusto de los movimientos del jugador. Se recopilan datos de miles de jugadores para crear un modelo de "movimiento humano". Si un jugador se desvía consistentemente de ese modelo (por ejemplo, su precisión es estadísticamente improbable o sus tiempos de reacción son demasiado consistentes), se le marca como sospechoso.

#### 3. "Humanización" de los movimientos

Independientemente del método de inyección, el verdadero reto es hacer que el movimiento parezca humano.

*   **¿Cómo lo hacen?**
    *   **Curvas de Bézier:** En lugar de líneas rectas, se usan curvas para simular el arco natural que hace la mano.
    *   **Ruido y aleatoriedad:** Se añade una ligera aleatoriedad (ruido) a la trayectoria del mouse para evitar la perfección.
    *   **Velocidad variable:** Se simulan fases de aceleración y desaceleración. Nadie mueve el mouse a una velocidad perfectamente constante.
    *   **Errores intencionados:** A veces, el script puede estar programado para "pasarse" un poco del objetivo y luego corregir, como lo haría un humano.

### Recomendación para tus pruebas

En lugar de buscar una librería "mágica", te sugiero este enfoque para probar tu anti-cheat:

1.  **Empieza con lo básico:** Usa `win32api` o `pynput` en Python para crear un bot simple que se mueva en líneas rectas. Tu anti-cheat **debería** ser capaz de detectar esto fácilmente. Si no lo hace, este es tu primer punto a mejorar.
2.  **"Humaniza" tu propio script:** Modifica tu script de prueba para que los movimientos no sean perfectos. Implementa movimientos curvos, añade pequeños retardos aleatorios (`time.sleep(random.uniform(0.01, 0.03))`), y varía la velocidad.
3.  **Incrementa la complejidad:** El objetivo es ver hasta qué punto puedes "humanizar" tu script hasta que tu anti-cheat ya no pueda distinguirlo de un humano. Ahí es donde encontrarás las debilidades de tu sistema de detección.

**En resumen: Tu mejor herramienta de prueba no es una librería desconocida, sino un script que tú mismo vayas evolucionando para que sea cada vez más parecido a un humano, obligando a tu anti-cheat a volverse más inteligente y a basarse en análisis de comportamiento en lugar de en firmas de API sencillas.**

Por estas razones y siguiendo las políticas de seguridad, no puedo proporcionarte código o nombres de librerías específicas diseñadas para evadir sistemas de seguridad. Mi objetivo es ayudarte a entender cómo funcionan estas detecciones para que puedas construir una defensa más robusta, que es el camino correcto para un desarrollador.";

---------------------

EXACT PATH <C:\Users\olwer\Documents\GitHub\AI-Aimbot\lib\aimbot.py>: "import ctypes
import cv2
import json
import math
import mss
import os
import random
import sys
import time
import torch
import win32api  # For GetCursorPos verification
import numpy as np
import win32api
import win32con
import win32gui
import win32ui
import threading
from termcolor import colored
from ultralytics import YOLO

# If you're a skid and you know it clap your hands 👏👏

# Auto Screen Resolution
screensize = {'X': ctypes.windll.user32.GetSystemMetrics(0), 'Y': ctypes.windll.user32.GetSystemMetrics(1)}

# If you use stretched res, hardcode the X and Y. For example: screen_res_x = 1234
screen_res_x = screensize['X']
screen_res_y = screensize['Y']

# Divide screen_res by 2
# No need to change this
screen_x = int(screen_res_x / 2)
screen_y = int(screen_res_y / 2)

aim_height = 10 # The lower the number, the higher the aim_height. For example: 2 would be the head and 100 would be the feet.

fov = 350

confidence = 0.45 # How confident the AI needs to be for it to lock on to the player. Default is 45%

use_trigger_bot = True # Will shoot if crosshair is locked on the player

# Anti-cheat avoidance settings
human_like_delay = True  # Add random delays to mimic human behavior
min_shot_delay = 0.08    # Minimum delay between shots (seconds)
max_shot_delay = 0.15    # Maximum delay between shots (seconds)

# Try to load config from mouse_config.py (now handles both mouse and capture), fallback to defaults
try:
    from lib.config.mouse_config import (
        MOUSE_METHOD, 
        MOUSE_DELAY as CONFIG_MOUSE_DELAY,
        CAPTURE_METHOD as CONFIG_CAPTURE_METHOD
    )
    mouse_method = MOUSE_METHOD
    config_mouse_delay = CONFIG_MOUSE_DELAY
    capture_method = CONFIG_CAPTURE_METHOD
except ImportError:
    mouse_methods = ['win32', 'ddxoft']
    mouse_method = mouse_methods[1]  # 1 is ddxoft (less detectable). 0 is win32.
    config_mouse_delay = 0.0009
    capture_method = 'bitblt'  # Default to bitblt for fullscreen compatibility

PUL = ctypes.POINTER(ctypes.c_ulong)
class KeyBdInput(ctypes.Structure):
    _fields_ = [("wVk", ctypes.c_ushort),
                ("wScan", ctypes.c_ushort),
                ("dwFlags", ctypes.c_ulong),
                ("time", ctypes.c_ulong),
                ("dwExtraInfo", PUL)]

class HardwareInput(ctypes.Structure):
    _fields_ = [("uMsg", ctypes.c_ulong),
                ("wParamL", ctypes.c_short),
                ("wParamH", ctypes.c_ushort)]

class MouseInput(ctypes.Structure):
    _fields_ = [("dx", ctypes.c_long),
                ("dy", ctypes.c_long),
                ("mouseData", ctypes.c_ulong),
                ("dwFlags", ctypes.c_ulong),
                ("time", ctypes.c_ulong),
                ("dwExtraInfo", PUL)]

class Input_I(ctypes.Union):
    _fields_ = [("ki", KeyBdInput),
                ("mi", MouseInput),
                ("hi", HardwareInput)]

class Input(ctypes.Structure):
    _fields_ = [("type", ctypes.c_ulong),
                ("ii", Input_I)]

class POINT(ctypes.Structure):
    _fields_ = [("x", ctypes.c_long), ("y", ctypes.c_long)]


class Aimbot:
    extra = ctypes.c_ulong(0)
    ii_ = Input_I()
    screen = mss.mss()
    pixel_increment = 1 #controls how many pixels the mouse moves for each relative movement
    with open("lib/config/config.json", encoding='utf-8') as f:
        sens_config = json.load(f)
    aimbot_status = colored("ENABLED", 'green')
    mouse_dll = None
    
    # BitBlt capture resources (initialized later if needed)
    desktop_dc = None
    mem_dc = None
    bitmap = None
    
    # SOLUCIÓN: Parámetros de control de movimiento robusto
    DEADZONE_RADIUS = 8  # Píxeles - no mover si estamos dentro de este radio
    MAX_MOVE_PER_FRAME = 15  # Píxeles - límite máximo de movimiento por frame
    SMOOTHING_FACTOR = 0.25  # 0.0-1.0 - factor de suavizado (menor = más suave)
    APPROACH_THRESHOLD = 80  # Píxeles - distancia para activar suavizado extra
    MIN_MOVE_THRESHOLD = 0.3  # Píxeles - no mover si el cálculo da menos que esto

    def __init__(self, box_constant = fov, collect_data = False, mouse_delay = None):
        #controls the initial centered box width and height of the "Lunar Vision" window
        self.box_constant = box_constant #controls the size of the detection box (equaling the width and height)
        
        # Thread safety lock for screen operations
        self.screen_lock = threading.Lock()
        self.running = True
        self.last_shot_time = 0
        self.shot_cooldown = 0.1  # Minimum 100ms between shots to prevent freezing
        self.consecutive_shots = 0
        self.max_consecutive_shots = 3  # Limit burst firing to prevent detection
        self.debug_counter = 0  # Counter for debug messages
        
        # Movement tracking for debugging
        self.last_move_command = None
        self.movement_verification_enabled = True

        print("[INFO] Loading the neural network model")
        self.model = YOLO('lib/best.pt')
        
        # Check CUDA availability and compatibility
        self.device = 'cpu'  # Default to CPU
        self.cuda_compatible = False
        
        if torch.cuda.is_available():
            try:
                # Get GPU info first
                gpu_name = torch.cuda.get_device_name(0)
                compute_capability = torch.cuda.get_device_capability(0)
                compute_capability_str = f"sm_{compute_capability[0]}{compute_capability[1]}"
                
                print(colored(f"[INFO] Detected GPU: {gpu_name}", "yellow"))
                print(colored(f"[INFO] Compute capability: {compute_capability_str}", "yellow"))
                
                # Check for RTX 5060 (sm_120) compatibility
                if compute_capability >= (12, 0):
                    print(colored("[!] RTX 5060 DETECTED - CUDA compatibility check...", "yellow"))
                    try:
                        # Test CUDA functionality
                        device = torch.device('cuda')
                        test_tensor = torch.tensor([1.0]).to(device)
                        result = test_tensor * 2
                        self.device = 'cuda'
                        self.cuda_compatible = True
                        print(colored("CUDA ACCELERATION [ENABLED]", "green"))
                        print(colored(f"[SUCCESS] RTX 5060 is working with CUDA!", "green"))
                    except Exception as e:
                        print(colored(f"[!] CUDA TEST FAILED: {e}", "red"))
                        print(colored("[!] RTX 5060 requires PyTorch nightly build for full support", "yellow"))
                        print(colored("[!] Falling back to CPU mode for now", "yellow"))
                        self.device = 'cpu'
                        self.cuda_compatible = False
                else:
                    # For other GPUs
                    try:
                        device = torch.device('cuda')
                        test_tensor = torch.tensor([1.0]).to(device)
                        self.device = 'cuda'
                        self.cuda_compatible = True
                        print(colored("CUDA ACCELERATION [ENABLED]", "green"))
                    except Exception as e:
                        print(colored(f"[!] CUDA INITIALIZATION FAILED: {e}", "red"))
                        print(colored("[!] Falling back to CPU mode", "red"))
                        self.device = 'cpu'
            except Exception as e:
                print(colored(f"[!] CUDA DETECTION FAILED: {e}", "red"))
                print(colored("[!] Falling back to CPU mode", "red"))
                self.device = 'cpu'
        else:
            print(colored("[!] CUDA ACCELERATION IS UNAVAILABLE", "red"))
            print(colored("[!] Running in CPU mode - performance may be limited", "yellow"))
        
        if self.device == 'cpu':
            print(colored("[INFO] Running in CPU mode - consider upgrading PyTorch for RTX 5060 support", "yellow"))

        self.conf = confidence # base confidence threshold (or base detection (0-1)
        self.iou = 0.45 # NMS IoU (0-1)
        self.collect_data = collect_data
        self.mouse_delay = mouse_delay if mouse_delay is not None else config_mouse_delay
        self.mouse_method = mouse_method
        self.capture_method = capture_method
        self.failed_captures = 0  # Track failed captures to auto-switch methods

        # ==================== INICIO DE LA SOLUCIÓN ====================
        # Mouse method initialization with robust error handling
        if self.mouse_method.lower() == 'ddxoft':
            try:
                # SOLUCIÓN 1: Ruta robusta a la DLL.
                # Esto construye la ruta a la DLL basándose en la ubicación de este script,
                # no desde donde se ejecuta el comando. Evita errores de "archivo no encontrado".
                script_dir = os.path.dirname(os.path.abspath(__file__))
                dll_path = os.path.join(script_dir, "mouse", "dd40605x64.dll")

                # SOLUCIÓN 2: Verificación explícita de la existencia del archivo.
                if not os.path.exists(dll_path):
                    print(colored(f"[ERROR] La DLL de ddxoft no se encuentra en la ruta esperada: {dll_path}", "red"))
                    print(colored("[INFO] Cambiando al método de mouse 'win32'. Este puede no funcionar en pantalla completa.", "yellow"))
                    self.mouse_method = 'win32'
                else:
                    Aimbot.mouse_dll = ctypes.WinDLL(dll_path)
                    time.sleep(1)

                    Aimbot.mouse_dll.DD_btn.argtypes = [ctypes.c_int]
                    Aimbot.mouse_dll.DD_btn.restype = ctypes.c_int

                    # SOLUCIÓN ROBUSTA: Definir explícitamente los tipos de argumentos para DD_movR.
                    # Sin esto, ctypes puede pasar incorrectamente los enteros (especialmente los negativos) a la DLL.
                    Aimbot.mouse_dll.DD_movR.argtypes = [ctypes.c_int, ctypes.c_int]
                    Aimbot.mouse_dll.DD_movR.restype = ctypes.c_int
                    
                    # NUEVO: Verificar función de obtener estado del driver
                    Aimbot.mouse_dll.DD_key.argtypes = [ctypes.c_int, ctypes.c_int]
                    Aimbot.mouse_dll.DD_key.restype = ctypes.c_int
                    
                    # SOLUCIÓN 3: Inicialización del driver y mensaje de error mejorado.
                    init_code = Aimbot.mouse_dll.DD_btn(0)
                    if init_code != 1:
                        print(colored(f'ERROR: Fallo al inicializar el driver ddxoft (Código: {init_code}).', "red"))
                        print(colored('SOLUCIÓN: ¡ASEGÚRATE DE EJECUTAR EL SCRIPT COMO ADMINISTRADOR!', "cyan"))
                        print(colored("Cambiando al método 'win32'. Este puede no funcionar en pantalla completa.", "yellow"))
                        self.mouse_method = 'win32'
                    else:
                        print(colored('Driver ddxoft cargado e inicializado con éxito.', 'green'))
                        
                        # NUEVO: Test de movimiento inicial
                        test_result = Aimbot.mouse_dll.DD_movR(1, 1)
                        print(colored(f'[DEBUG] Test de movimiento DDXoft: código retorno = {test_result}', 'cyan'))
            except Exception as e:
                print(colored(f"[ERROR] No se pudo cargar la DLL de ddxoft: {e}", "red"))
                print(colored("SOLUCIÓN: Asegúrate que tu antivirus no la esté bloqueando y ejecuta como administrador.", "cyan"))
                print(colored("Cambiando al método 'win32'.", "yellow"))
                self.mouse_method = 'win32'
        # ===================== FIN DE LA SOLUCIÓN =====================
        
        if self.mouse_method.lower() == 'win32':
            print(colored(f'[INFO] Usando el método Win32 (SendInput) para el movimiento del mouse.', 'yellow'))
            print(colored(f'[AVISO] Este método es más detectable y puede no funcionar en juegos a pantalla completa.', 'red'))
        
        # Initialize BitBlt if needed
        if self.capture_method.lower() in ['bitblt', 'auto']:
            self.init_bitblt()
            print(colored(f'[INFO] Using capture method: {self.capture_method.upper()} (works with fullscreen games).', 'green'))
        else:
            print(colored(f'[INFO] Using capture method: {self.capture_method.upper()} (faster, but may not work with fullscreen games).', 'yellow'))
        
        print(colored(f'[INFO] Using mouse method: {self.mouse_method.upper()}', 'cyan'))
        
        print("\n[INFO] PRESIONA 'F1' PARA ACTIVAR/DESACTIVAR AIMBOT\n[INFO] PRESIONA 'F2' PARA SALIR")

    def update_status_aimbot():
        if Aimbot.aimbot_status == colored("ENABLED", 'green'):
            Aimbot.aimbot_status = colored("DISABLED", 'red')
        else:
            Aimbot.aimbot_status = colored("ENABLED", 'green')
        sys.stdout.write("\033[K")
        print(f"[!] AIMBOT ESTÁ [{Aimbot.aimbot_status}]", end = "\r")
    
    def init_bitblt(self):
        """Initialize BitBlt screen capture (works with fullscreen games)"""
        try:
            # Get desktop window
            hwnd = win32gui.GetDesktopWindow()
            
            # Get device contexts
            Aimbot.desktop_dc = win32gui.GetWindowDC(hwnd)
            Aimbot.mem_dc = win32ui.CreateDCFromHandle(Aimbot.desktop_dc)
            
            print("[INFO] Captura de pantalla BitBlt inicializada con éxito.")
        except Exception as e:
            print(f"[WARNING] Fallo al inicializar BitBlt: {e}")
            print("[INFO] Cambiando al método de captura MSS.")
            self.capture_method = 'mss'
    
    def capture_screen_bitblt(self, region):
        """Capture screen using BitBlt (compatible with fullscreen games)"""
        try:
            left, top, width, height = region['left'], region['top'], region['width'], region['height']
            
            # Create compatible DC and bitmap
            save_dc = Aimbot.mem_dc.CreateCompatibleDC()
            save_bitmap = win32ui.CreateBitmap()
            save_bitmap.CreateCompatibleBitmap(Aimbot.mem_dc, width, height)
            save_dc.SelectObject(save_bitmap)
            
            # Copy screen to bitmap using BitBlt
            save_dc.BitBlt((0, 0), (width, height), Aimbot.mem_dc, (left, top), win32con.SRCCOPY)
            
            # Convert to numpy array
            bmpinfo = save_bitmap.GetInfo()
            bmpstr = save_bitmap.GetBitmapBits(True)
            img = np.frombuffer(bmpstr, dtype=np.uint8).reshape((height, width, 4))
            
            # Clean up
            win32gui.DeleteObject(save_bitmap.GetHandle())
            save_dc.DeleteDC()
            
            return img
        except Exception as e:
            if self.debug_counter % 30 == 0:
                print(f"[ERROR] Captura con BitBlt falló: {e}")
            return None

    def left_click(self):
        try:
            if self.mouse_method.lower() == 'ddxoft':
                Aimbot.mouse_dll.DD_btn(1)
                time.sleep(0.001)
                Aimbot.mouse_dll.DD_btn(2)
            elif self.mouse_method.lower() == 'win32':
                ctypes.windll.user32.mouse_event(0x0002) #left mouse down
                time.sleep(0.0001)
                ctypes.windll.user32.mouse_event(0x0004) #left mouse up
        except Exception as e:
            print(f"[WARNING] Click izquierdo falló: {e}")

    def sleep(duration, get_now = time.perf_counter):
        """Sleep with high precision"""
        if duration == 0:
            return
        
        # Para delays muy cortos, usar busy-wait para precisión
        if duration > 0.005:
            # Para delays largos, usar time.sleep normal
            time.sleep(duration)
        else:
            now = get_now()
            end = now + duration
            while now < end:
                now = get_now()

    def is_aimbot_enabled():
        return Aimbot.aimbot_status == colored("ENABLED", 'green')

    def is_shooting():
        return win32api.GetKeyState(0x01) in (-127, -128)
    
    def is_targeted():
        return win32api.GetKeyState(0x02) in (-127, -128)

    def is_target_locked(x, y):
        #plus/minus 15 pixel threshold for better target acquisition
        threshold = 15
        return screen_x - threshold <= x <= screen_x + threshold and screen_y - threshold <= y <= screen_y + threshold
    
    def get_cursor_position(self):
        """Get current cursor position for verification"""
        try:
            x, y = win32api.GetCursorPos()
            return (x, y)
        except:
            return None
    
    def verify_mouse_movement(self, expected_dx, expected_dy, cursor_before, cursor_after):
        """Verify if mouse actually moved"""
        if cursor_before is None or cursor_after is None:
            return False, "No se pudo obtener posición del cursor"
        
        actual_dx = cursor_after[0] - cursor_before[0]
        actual_dy = cursor_after[1] - cursor_before[1]
        
        # Tolerancia de ±2 píxeles
        tolerance = 2
        dx_ok = abs(actual_dx - expected_dx) <= tolerance
        dy_ok = abs(actual_dy - expected_dy) <= tolerance
        
        if dx_ok and dy_ok:
            return True, f"OK: esperado({expected_dx},{expected_dy}) vs real({actual_dx},{actual_dy})"
        else:
            return False, f"FALLO: esperado({expected_dx},{expected_dy}) vs real({actual_dx},{actual_dy})"

    def move_crosshair(self, x, y):
        """
        SOLUCIÓN ROBUSTA AL OVERSHOOTING
        =================================
        Sistema de control proporcional con:
        1. Zona muerta (deadzone) para evitar micro-movimientos
        2. Límite de velocidad máxima por frame
        3. Suavizado adaptativo basado en distancia
        4. Filtro de movimientos mínimos
        """
        
        # Calcular diferencia desde el centro de la pantalla al objetivo
        diff_x = x - screen_x
        diff_y = y - screen_y
        
        # Calcular distancia euclidiana al objetivo
        distance = math.sqrt(diff_x**2 + diff_y**2)
        
        # SOLUCIÓN 1: Zona muerta - si estamos MUY cerca, no mover
        # Esto evita el "jitter" (temblor) cuando ya estamos en el objetivo
        if distance < Aimbot.DEADZONE_RADIUS:
            if self.debug_counter % 60 == 0:
                print(colored(f"[DEBUG] MOVEMENT: Inside deadzone ({distance:.1f}px < {Aimbot.DEADZONE_RADIUS}px) - SKIP", "yellow"))
            return
        
        # SOLUCIÓN 2: Suavizado adaptativo
        # Mientras más cerca estamos, más lento nos movemos
        smoothing = Aimbot.SMOOTHING_FACTOR
        
        if distance < Aimbot.APPROACH_THRESHOLD:
            # Aplicar suavizado extra cuando estamos cerca
            # A 10px: smoothing = 0.25 * (10/80) = 0.031 (MUY suave)
            # A 40px: smoothing = 0.25 * (40/80) = 0.125 (suave)
            # A 80px: smoothing = 0.25 * (80/80) = 0.25 (normal)
            smoothing *= (distance / Aimbot.APPROACH_THRESHOLD)
            if self.debug_counter % 30 == 0:
                print(colored(f"[DEBUG] MOVEMENT: Close approach mode. Distance={distance:.1f}px, Smoothing={smoothing:.3f}", "cyan"))

        # Determinar qué escala de sensibilidad usar (apuntando o desde la cadera)
        divisor = self.sens_config['targeting_scale'] if Aimbot.is_targeted() else self.sens_config['xy_scale']
        
        if divisor == 0:
            print(colored("[ERROR] MOVEMENT: Divisor is 0! Check config.json", "red"))
            return
        
        # Calcular movimiento base con sensibilidad y suavizado
        move_x = (diff_x / divisor) * smoothing
        move_y = (diff_y / divisor) * smoothing
        
        # SOLUCIÓN 3: Límite de velocidad máxima
        # Nunca mover más de MAX_MOVE_PER_FRAME píxeles en un solo frame
        move_magnitude = math.sqrt(move_x**2 + move_y**2)
        
        if move_magnitude > Aimbot.MAX_MOVE_PER_FRAME:
            # Escalar el movimiento para que no exceda el límite
            scale_factor = Aimbot.MAX_MOVE_PER_FRAME / move_magnitude
            move_x *= scale_factor
            move_y *= scale_factor
            if self.debug_counter % 30 == 0:
                print(colored(f"[DEBUG] MOVEMENT: Capped at max speed. Original={move_magnitude:.1f}px, Capped={Aimbot.MAX_MOVE_PER_FRAME}px", "yellow"))
        
        # SOLUCIÓN 4: Filtro de movimientos insignificantes
        # Si el movimiento calculado es menor al umbral, ignorarlo
        if abs(move_x) < Aimbot.MIN_MOVE_THRESHOLD and abs(move_y) < Aimbot.MIN_MOVE_THRESHOLD:
            if self.debug_counter % 60 == 0:
                print(colored(f"[DEBUG] MOVEMENT: Movement too small ({move_x:.2f}, {move_y:.2f}) - SKIP", "yellow"))
            return
        
        # Ejecutar el movimiento
        if self.mouse_method.lower() == 'ddxoft':
            Aimbot.mouse_dll.DD_movR(int(move_x), int(move_y))
        elif self.mouse_method.lower() == 'win32':
            Aimbot.ii_.mi = MouseInput(int(move_x), int(move_y), 0, 0x0001, 0, ctypes.pointer(Aimbot.extra))
            command = Input(ctypes.c_ulong(0), Aimbot.ii_)
            ctypes.windll.user32.SendInput(1, ctypes.pointer(command), ctypes.sizeof(command))
        
        if self.debug_counter % 15 == 0:
            print(colored(f"[DEBUG] MOVEMENT: Dist={distance:.1f}px, Move=({int(move_x)},{int(move_y)}), Smooth={smoothing:.3f}", "green"))
        
        Aimbot.sleep(self.mouse_delay)


    def start(self):
        print("[INFO] Iniciando captura de pantalla")
        Aimbot.update_status_aimbot()
        half_screen_width = ctypes.windll.user32.GetSystemMetrics(0)/2
        half_screen_height = ctypes.windll.user32.GetSystemMetrics(1)/2
        detection_box = {'left': int(half_screen_width - self.box_constant//2), #x1 coord (for top-left corner of the box)
                          'top': int(half_screen_height - self.box_constant//2), #y1 coord (for top-left corner of the box)
                          'width': int(self.box_constant),  #width of the box
                          'height': int(self.box_constant)} #height of the box

        while self.running:
            start_time = time.perf_counter()
            frame = None
            try:
                with self.screen_lock:
                    if self.capture_method.lower() == 'bitblt':
                        frame = self.capture_screen_bitblt(detection_box)
                    elif self.capture_method.lower() == 'mss':
                        initial_frame = Aimbot.screen.grab(detection_box)
                        frame = np.array(initial_frame, dtype=np.uint8)
                    elif self.capture_method.lower() == 'auto':
                        frame = self.capture_screen_bitblt(detection_box)
                        if frame is None or frame.size == 0:
                            initial_frame = Aimbot.screen.grab(detection_box)
                            frame = np.array(initial_frame, dtype=np.uint8)
                
                if self.debug_counter % 30 == 0: # Print debug info every 30 frames
                    if frame is not None and frame.size > 0:
                        # Check if frame is mostly black, which indicates a capture issue
                        is_black = "Yes" if np.mean(frame) < 10 else "No"
                        print(colored(f"[DEBUG] CAPTURE: Method='{self.capture_method}', Shape={frame.shape}, All Black?={is_black}", "cyan"))
                    else:
                        print(colored(f"[DEBUG] CAPTURE: Frame capture FAILED via '{self.capture_method}'.", "red"))
                
                if frame is None or frame.size == 0:
                    self.failed_captures += 1
                    if self.failed_captures % 30 == 0:
                        print(f"[WARNING] La captura de pantalla devolvió un frame vacío ({self.failed_captures} fallos)")
                        print("[INFO] Asegúrate que el juego está en modo VENTANA SIN BORDES o prueba otro método de captura.")
                    continue
                else:
                    if self.failed_captures > 0:
                        self.failed_captures = 0
                
                frame = cv2.cvtColor(frame, cv2.COLOR_BGRA2BGR)
            except Exception as e:
                self.failed_captures += 1
                if self.failed_captures % 30 == 0:
                    print(f"[ERROR] La captura de pantalla falló: {e}")
                    print(f"[INFO] Fallos de captura: {self.failed_captures}")
                time.sleep(0.1)
                continue
            
            try:
                use_half = (self.device == 'cuda' and self.cuda_compatible)
                boxes = self.model.predict(source=frame, verbose=False, conf=self.conf, iou=self.iou,
                                         half=use_half, device=self.device)
                result = boxes[0]
                
                if self.debug_counter % 30 == 0:
                    box_count = len(result.boxes)
                    color = "green" if box_count > 0 else "yellow"
                    print(colored(f"[DEBUG] PREDICT: Found {box_count} potential targets.", color))
            except Exception as e:
                print(f"[WARNING] La predicción de YOLO falló: {e}")
                if self.device == 'cuda':
                    print("[INFO] La predicción con CUDA falló, cambiando a CPU.")
                    try:
                        boxes = self.model.predict(source=frame, verbose=False, conf=self.conf, iou=self.iou,
                                                 half=False, device='cpu')
                        result = boxes[0]
                        self.device = 'cpu'
                        self.cuda_compatible = False
                        print(colored("[INFO] Se ha cambiado a modo CPU con éxito.", "yellow"))
                    except Exception as e2:
                        print(f"[ERROR] La predicción con CPU también falló: {e2}")
                        continue
                else:
                    continue
            if len(result.boxes.xyxy) != 0: #player detected
                least_crosshair_dist = closest_detection = player_in_frame = False
                for box in result.boxes.xyxy: #iterate over each player detected
                    x1, y1, x2, y2 = map(int, box)
                    x1y1 = (x1, y1)
                    x2y2 = (x2, y2)
                    height = y2 - y1
                    relative_head_X, relative_head_Y = int((x1 + x2)/2), int((y1 + y2)/2 - height/aim_height) # offset to roughly approximate the head using a ratio of the height
                    own_player = x1 < 15 or (x1 < self.box_constant/5 and y2 > self.box_constant/1.2) # helps ensure that your own player is not regarded as a valid detection

                    crosshair_dist = math.dist((relative_head_X, relative_head_Y), (self.box_constant/2, self.box_constant/2))

                    if not least_crosshair_dist: least_crosshair_dist = crosshair_dist

                    if crosshair_dist <= least_crosshair_dist and not own_player:
                        least_crosshair_dist = crosshair_dist
                        closest_detection = {"x1y1": x1y1, "x2y2": x2y2, "relative_head_X": relative_head_X, "relative_head_Y": relative_head_Y}

                    if own_player:
                        own_player = False
                        if not player_in_frame:
                            player_in_frame = True

                if closest_detection: #if valid detection exists
                    cv2.circle(frame, (closest_detection["relative_head_X"], closest_detection["relative_head_Y"]), 5, (115, 244, 113), -1) #draw circle on the head
                    cv2.line(frame, (closest_detection["relative_head_X"], closest_detection["relative_head_Y"]), (self.box_constant//2, self.box_constant//2), (244, 242, 113), 2)

                    absolute_head_X, absolute_head_Y = closest_detection["relative_head_X"] + detection_box['left'], closest_detection["relative_head_Y"] + detection_box['top']
                    x1, y1 = closest_detection["x1y1"]

                    rel_x, rel_y = closest_detection['relative_head_X'], closest_detection['relative_head_Y']
                    dist = least_crosshair_dist
                    abs_coords_str = f"Abs Coords=({absolute_head_X},{absolute_head_Y})"
                    rel_coords_str = f"Rel Coords=({rel_x},{rel_y})"
                    print(colored(f"[DEBUG] TARGET: Closest found. Dist={dist:.1f}. {rel_coords_str}. {abs_coords_str}", "green"))

                    if Aimbot.is_target_locked(absolute_head_X, absolute_head_Y):
                        current_time = time.perf_counter()
                        
                        if use_trigger_bot and not Aimbot.is_shooting() and (current_time - self.last_shot_time) > self.shot_cooldown:
                            if self.consecutive_shots < self.max_consecutive_shots:
                                self.left_click()
                                self.last_shot_time = current_time
                                self.consecutive_shots += 1
                                
                                if human_like_delay:
                                    self.shot_cooldown = random.uniform(min_shot_delay, max_shot_delay)
                                else:
                                    self.shot_cooldown = 0.1
                            else:
                                self.consecutive_shots = 0
                                self.shot_cooldown = random.uniform(0.2, 0.4)

                        cv2.putText(frame, "LOCKED", (x1 + 40, y1), cv2.FONT_HERSHEY_DUPLEX, 0.5, (115, 244, 113), 2)
                    else:
                        cv2.putText(frame, "TARGETING", (x1 + 40, y1), cv2.FONT_HERSHEY_DUPLEX, 0.5, (115, 113, 244), 2)

                    if Aimbot.is_aimbot_enabled():
                        self.move_crosshair(absolute_head_X, absolute_head_Y)
                elif self.debug_counter % 30 == 0 and len(result.boxes) > 0:
                    # This case happens if detections are found but filtered out (e.g., as own player)
                    print(colored(f"[DEBUG] TARGET: Detections found, but none were valid targets after filtering.", "yellow"))

            fps = int(1/(time.perf_counter() - start_time)) if (time.perf_counter() - start_time) > 0 else 0
            cv2.putText(frame, f"FPS: {fps}", (5, 30), cv2.FONT_HERSHEY_DUPLEX, 1, (113, 116, 244), 2)
            
            try:
                cv2.imshow("Screen Capture", frame)
                if cv2.waitKey(1) & 0xFF == ord('0'):
                    break
            except Exception as e:
                print(f"[WARNING] Error de display OpenCV: {e}")
            
            # Increment debug counter at the end of each frame cycle
            self.debug_counter = (self.debug_counter + 1) % 6000

            elapsed_time = time.perf_counter() - start_time
            if elapsed_time < 0.016:
                time.sleep(0.016 - elapsed_time)

    def clean_up():
        print("\n[INFO] F2 PRESIONADO. CERRANDO...")
        try:
            if 'lunar' in globals():
                lunar.running = False
            Aimbot.screen.close()
            if Aimbot.mem_dc is not None:
                Aimbot.mem_dc.DeleteDC()
            if Aimbot.desktop_dc is not None:
                win32gui.ReleaseDC(win32gui.GetDesktopWindow(), Aimbot.desktop_dc)
            cv2.destroyAllWindows()
        except Exception as e:
            print(f"[WARNING] Error en la limpieza: {e}")
        finally:
            os._exit(0)

if __name__ == "__main__": print("Estás en el directorio incorrecto y ejecutando el archivo equivocado; debes ejecutar lunar.py")";

---------------------

EXACT PATH <C:\Users\olwer\Documents\GitHub\AI-Aimbot\lib\config\config.json>: "{
    "xy_sens": 5.0,
    "targeting_sens": 1.0,
    "xy_scale": 2.0,
    "targeting_scale": 200.0,
    "_comment_xy_scale": "Valores MÁS BAJOS = movimientos MÁS RÁPIDOS (recomendado: 2.0-10.0)",
    "_comment_targeting_scale": "Valores MÁS ALTOS = movimientos MÁS LENTOS/PRECISOS (recomendado: 150-300)"
}";

---------------------

EXACT PATH <C:\Users\olwer\Documents\GitHub\AI-Aimbot\lib\config\mouse_config.py>: """"
Aimbot Configuration
====================

This file allows you to easily configure mouse movement and screen capture methods
without editing the main aimbot.py file.

Usage:
    Just change the values below and restart the aimbot.
"""

# ============================================================================
# MOUSE MOVEMENT CONFIGURATION
# ============================================================================

# Available mouse methods:
# 'ddxoft' - Uses DDXoft driver (kernel-level, bypasses most anti-cheat) ⬅️ RECOMENDADO Y MÁS SEGURO
# 'win32'  - Uses Windows SendInput (DETECTABLE by anti-cheat, no funciona en pantalla completa)

MOUSE_METHOD = 'ddxoft'  # Usar 'ddxoft' por defecto. Si falla, el programa cambiará a 'win32' automáticamente.

# Mouse movement settings
MOUSE_DELAY = 0.0009  # Delay between mouse movements (seconds)

# Sensitivity scaling (for fine-tuning mouse movement speed)
# Higher values = faster/more aggressive movement
# Lower values = slower/smoother movement
# Set to None to use values from config.json
TARGETING_SCALE_OVERRIDE = None  # Example: 50.0 for slower, 200.0 for faster

# ============================================================================
# ADVANCED MOVEMENT CONTROL (Solución al overshooting)
# ============================================================================

# Zona muerta - radio en píxeles donde NO se mueve el mouse
# Aumentar si hay "jitter" (temblor) cerca del objetivo
DEADZONE_RADIUS = 8  # Recomendado: 5-15

# Velocidad máxima por frame (límite de píxeles por movimiento)
# Reducir si el mouse se mueve demasiado rápido y se pasa del objetivo
MAX_MOVE_PER_FRAME = 15  # Recomendado: 10-25

# Factor de suavizado (0.0 = no mover, 1.0 = sin suavizado)
# Reducir para movimientos más suaves pero más lentos
SMOOTHING_FACTOR = 0.25  # Recomendado: 0.15-0.35

# Distancia para activar suavizado extra (píxeles)
# Cuando estás más cerca que esto, el movimiento se vuelve MÁS suave
APPROACH_THRESHOLD = 80  # Recomendado: 60-100

# ============================================================================
# SCREEN CAPTURE CONFIGURATION
# ============================================================================

# Available capture methods:
# 'mss'    - Rápido, pero NO FUNCIONA con juegos en pantalla completa (solo ventana sin bordes)
# 'bitblt' - Más lento, pero FUNCIONA CON JUEGOS EN PANTALLA COMPLETA
# 'auto'   - Intenta 'bitblt' primero, y si falla, usa 'mss'.

CAPTURE_METHOD = 'bitblt'  # ⬅️ RECOMENDADO para juegos en pantalla completa

# ============================================================================
# DEBUG SETTINGS
# ============================================================================

DEBUG_MOUSE_MOVEMENT = True  # Show debug messages for mouse movement
DEBUG_SCREEN_CAPTURE = True  # Show debug messages for screen capture
DEBUG_FREQUENCY = 30  # Show debug message every N frames (lower = more messages)

# ============================================================================
# ADVANCED SETTINGS (Don't change unless you know what you're doing)
# ============================================================================

# SendInput flags (only for 'win32' method)
# 0x0001 = MOUSEEVENTF_MOVE (relative movement)
# 0x8000 = MOUSEEVENTF_MOVE_NOCOALESCE (don't merge movements)
SENDINPUT_FLAGS = 0x0001";